// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hexz.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_hexz_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_hexz_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_hexz_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_hexz_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_hexz_2eproto;
namespace hexzpb {
class AddTrainingExamplesRequest;
struct AddTrainingExamplesRequestDefaultTypeInternal;
extern AddTrainingExamplesRequestDefaultTypeInternal _AddTrainingExamplesRequest_default_instance_;
class AddTrainingExamplesResponse;
struct AddTrainingExamplesResponseDefaultTypeInternal;
extern AddTrainingExamplesResponseDefaultTypeInternal _AddTrainingExamplesResponse_default_instance_;
class Board;
struct BoardDefaultTypeInternal;
extern BoardDefaultTypeInternal _Board_default_instance_;
class Field;
struct FieldDefaultTypeInternal;
extern FieldDefaultTypeInternal _Field_default_instance_;
class GameEngineClassicState;
struct GameEngineClassicStateDefaultTypeInternal;
extern GameEngineClassicStateDefaultTypeInternal _GameEngineClassicState_default_instance_;
class GameEngineFlagzState;
struct GameEngineFlagzStateDefaultTypeInternal;
extern GameEngineFlagzStateDefaultTypeInternal _GameEngineFlagzState_default_instance_;
class GameEngineFreeformState;
struct GameEngineFreeformStateDefaultTypeInternal;
extern GameEngineFreeformStateDefaultTypeInternal _GameEngineFreeformState_default_instance_;
class GameEngineMove;
struct GameEngineMoveDefaultTypeInternal;
extern GameEngineMoveDefaultTypeInternal _GameEngineMove_default_instance_;
class GameEngineState;
struct GameEngineStateDefaultTypeInternal;
extern GameEngineStateDefaultTypeInternal _GameEngineState_default_instance_;
class GameInfo;
struct GameInfoDefaultTypeInternal;
extern GameInfoDefaultTypeInternal _GameInfo_default_instance_;
class GameState;
struct GameStateDefaultTypeInternal;
extern GameStateDefaultTypeInternal _GameState_default_instance_;
class MCTSExample;
struct MCTSExampleDefaultTypeInternal;
extern MCTSExampleDefaultTypeInternal _MCTSExample_default_instance_;
class MCTSExample_MoveStats;
struct MCTSExample_MoveStatsDefaultTypeInternal;
extern MCTSExample_MoveStatsDefaultTypeInternal _MCTSExample_MoveStats_default_instance_;
class ModelKey;
struct ModelKeyDefaultTypeInternal;
extern ModelKeyDefaultTypeInternal _ModelKey_default_instance_;
class Player;
struct PlayerDefaultTypeInternal;
extern PlayerDefaultTypeInternal _Player_default_instance_;
class ResourceInfo;
struct ResourceInfoDefaultTypeInternal;
extern ResourceInfoDefaultTypeInternal _ResourceInfo_default_instance_;
class SuggestMoveRequest;
struct SuggestMoveRequestDefaultTypeInternal;
extern SuggestMoveRequestDefaultTypeInternal _SuggestMoveRequest_default_instance_;
class SuggestMoveResponse;
struct SuggestMoveResponseDefaultTypeInternal;
extern SuggestMoveResponseDefaultTypeInternal _SuggestMoveResponse_default_instance_;
class SuggestMoveStats;
struct SuggestMoveStatsDefaultTypeInternal;
extern SuggestMoveStatsDefaultTypeInternal _SuggestMoveStats_default_instance_;
class SuggestMoveStats_Score;
struct SuggestMoveStats_ScoreDefaultTypeInternal;
extern SuggestMoveStats_ScoreDefaultTypeInternal _SuggestMoveStats_Score_default_instance_;
class SuggestMoveStats_ScoredMove;
struct SuggestMoveStats_ScoredMoveDefaultTypeInternal;
extern SuggestMoveStats_ScoredMoveDefaultTypeInternal _SuggestMoveStats_ScoredMove_default_instance_;
class TrainingExample;
struct TrainingExampleDefaultTypeInternal;
extern TrainingExampleDefaultTypeInternal _TrainingExample_default_instance_;
class TrainingExample_ModelPredictions;
struct TrainingExample_ModelPredictionsDefaultTypeInternal;
extern TrainingExample_ModelPredictionsDefaultTypeInternal _TrainingExample_ModelPredictions_default_instance_;
class TrainingExample_Stats;
struct TrainingExample_StatsDefaultTypeInternal;
extern TrainingExample_StatsDefaultTypeInternal _TrainingExample_Stats_default_instance_;
}  // namespace hexzpb
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace hexzpb {
enum Board_GameState : int {
  Board_GameState_INITIAL = 0,
  Board_GameState_RUNNING = 1,
  Board_GameState_FINISHED = 2,
  Board_GameState_Board_GameState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Board_GameState_Board_GameState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Board_GameState_IsValid(int value);
constexpr Board_GameState Board_GameState_GameState_MIN = static_cast<Board_GameState>(0);
constexpr Board_GameState Board_GameState_GameState_MAX = static_cast<Board_GameState>(2);
constexpr int Board_GameState_GameState_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Board_GameState_descriptor();
template <typename T>
const std::string& Board_GameState_Name(T value) {
  static_assert(std::is_same<T, Board_GameState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to GameState_Name().");
  return Board_GameState_Name(static_cast<Board_GameState>(value));
}
template <>
inline const std::string& Board_GameState_Name(Board_GameState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Board_GameState_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Board_GameState_Parse(absl::string_view name, Board_GameState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Board_GameState>(
      Board_GameState_descriptor(), name, value);
}
enum Field_CellType : int {
  Field_CellType_NORMAL = 0,
  Field_CellType_DEAD = 1,
  Field_CellType_GRASS = 2,
  Field_CellType_ROCK = 3,
  Field_CellType_FIRE = 4,
  Field_CellType_FLAG = 5,
  Field_CellType_PEST = 6,
  Field_CellType_DEATH = 7,
  Field_CellType_Field_CellType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Field_CellType_Field_CellType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Field_CellType_IsValid(int value);
constexpr Field_CellType Field_CellType_CellType_MIN = static_cast<Field_CellType>(0);
constexpr Field_CellType Field_CellType_CellType_MAX = static_cast<Field_CellType>(7);
constexpr int Field_CellType_CellType_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
Field_CellType_descriptor();
template <typename T>
const std::string& Field_CellType_Name(T value) {
  static_assert(std::is_same<T, Field_CellType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CellType_Name().");
  return Field_CellType_Name(static_cast<Field_CellType>(value));
}
template <>
inline const std::string& Field_CellType_Name(Field_CellType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Field_CellType_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool Field_CellType_Parse(absl::string_view name, Field_CellType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Field_CellType>(
      Field_CellType_descriptor(), name, value);
}
enum SuggestMoveStats_ScoreKind : int {
  SuggestMoveStats_ScoreKind_FINAL = 0,
  SuggestMoveStats_ScoreKind_MCTS_PRIOR = 1,
  SuggestMoveStats_ScoreKind_SuggestMoveStats_ScoreKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SuggestMoveStats_ScoreKind_SuggestMoveStats_ScoreKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SuggestMoveStats_ScoreKind_IsValid(int value);
constexpr SuggestMoveStats_ScoreKind SuggestMoveStats_ScoreKind_ScoreKind_MIN = static_cast<SuggestMoveStats_ScoreKind>(0);
constexpr SuggestMoveStats_ScoreKind SuggestMoveStats_ScoreKind_ScoreKind_MAX = static_cast<SuggestMoveStats_ScoreKind>(1);
constexpr int SuggestMoveStats_ScoreKind_ScoreKind_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
SuggestMoveStats_ScoreKind_descriptor();
template <typename T>
const std::string& SuggestMoveStats_ScoreKind_Name(T value) {
  static_assert(std::is_same<T, SuggestMoveStats_ScoreKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ScoreKind_Name().");
  return SuggestMoveStats_ScoreKind_Name(static_cast<SuggestMoveStats_ScoreKind>(value));
}
template <>
inline const std::string& SuggestMoveStats_ScoreKind_Name(SuggestMoveStats_ScoreKind value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SuggestMoveStats_ScoreKind_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool SuggestMoveStats_ScoreKind_Parse(absl::string_view name, SuggestMoveStats_ScoreKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SuggestMoveStats_ScoreKind>(
      SuggestMoveStats_ScoreKind_descriptor(), name, value);
}
enum AddTrainingExamplesResponse_Status : int {
  AddTrainingExamplesResponse_Status_STATUS_UNSPECIFIED = 0,
  AddTrainingExamplesResponse_Status_ACCEPTED = 1,
  AddTrainingExamplesResponse_Status_REJECTED_WRONG_MODEL = 2,
  AddTrainingExamplesResponse_Status_REJECTED_AT_CAPACITY = 3,
  AddTrainingExamplesResponse_Status_REJECTED_OTHER = 4,
  AddTrainingExamplesResponse_Status_AddTrainingExamplesResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AddTrainingExamplesResponse_Status_AddTrainingExamplesResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AddTrainingExamplesResponse_Status_IsValid(int value);
constexpr AddTrainingExamplesResponse_Status AddTrainingExamplesResponse_Status_Status_MIN = static_cast<AddTrainingExamplesResponse_Status>(0);
constexpr AddTrainingExamplesResponse_Status AddTrainingExamplesResponse_Status_Status_MAX = static_cast<AddTrainingExamplesResponse_Status>(4);
constexpr int AddTrainingExamplesResponse_Status_Status_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
AddTrainingExamplesResponse_Status_descriptor();
template <typename T>
const std::string& AddTrainingExamplesResponse_Status_Name(T value) {
  static_assert(std::is_same<T, AddTrainingExamplesResponse_Status>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Status_Name().");
  return AddTrainingExamplesResponse_Status_Name(static_cast<AddTrainingExamplesResponse_Status>(value));
}
template <>
inline const std::string& AddTrainingExamplesResponse_Status_Name(AddTrainingExamplesResponse_Status value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AddTrainingExamplesResponse_Status_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool AddTrainingExamplesResponse_Status_Parse(absl::string_view name, AddTrainingExamplesResponse_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AddTrainingExamplesResponse_Status>(
      AddTrainingExamplesResponse_Status_descriptor(), name, value);
}
enum TrainingExample_Encoding : int {
  TrainingExample_Encoding_NUMPY = 0,
  TrainingExample_Encoding_PYTORCH = 1,
  TrainingExample_Encoding_TrainingExample_Encoding_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TrainingExample_Encoding_TrainingExample_Encoding_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TrainingExample_Encoding_IsValid(int value);
constexpr TrainingExample_Encoding TrainingExample_Encoding_Encoding_MIN = static_cast<TrainingExample_Encoding>(0);
constexpr TrainingExample_Encoding TrainingExample_Encoding_Encoding_MAX = static_cast<TrainingExample_Encoding>(1);
constexpr int TrainingExample_Encoding_Encoding_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
TrainingExample_Encoding_descriptor();
template <typename T>
const std::string& TrainingExample_Encoding_Name(T value) {
  static_assert(std::is_same<T, TrainingExample_Encoding>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Encoding_Name().");
  return TrainingExample_Encoding_Name(static_cast<TrainingExample_Encoding>(value));
}
template <>
inline const std::string& TrainingExample_Encoding_Name(TrainingExample_Encoding value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TrainingExample_Encoding_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool TrainingExample_Encoding_Parse(absl::string_view name, TrainingExample_Encoding* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrainingExample_Encoding>(
      TrainingExample_Encoding_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Board final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hexzpb.Board) */ {
 public:
  inline Board() : Board(nullptr) {}
  ~Board() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Board(::google::protobuf::internal::ConstantInitialized);

  Board(const Board& from);
  Board(Board&& from) noexcept
    : Board() {
    *this = ::std::move(from);
  }

  inline Board& operator=(const Board& from) {
    CopyFrom(from);
    return *this;
  }
  inline Board& operator=(Board&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Board& default_instance() {
    return *internal_default_instance();
  }
  static inline const Board* internal_default_instance() {
    return reinterpret_cast<const Board*>(
               &_Board_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Board& a, Board& b) {
    a.Swap(&b);
  }
  inline void Swap(Board* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Board* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Board* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Board>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Board& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Board& from) {
    Board::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Board* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hexzpb.Board";
  }
  protected:
  explicit Board(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using GameState = Board_GameState;
  static constexpr GameState INITIAL = Board_GameState_INITIAL;
  static constexpr GameState RUNNING = Board_GameState_RUNNING;
  static constexpr GameState FINISHED = Board_GameState_FINISHED;
  static inline bool GameState_IsValid(int value) {
    return Board_GameState_IsValid(value);
  }
  static constexpr GameState GameState_MIN = Board_GameState_GameState_MIN;
  static constexpr GameState GameState_MAX = Board_GameState_GameState_MAX;
  static constexpr int GameState_ARRAYSIZE = Board_GameState_GameState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* GameState_descriptor() {
    return Board_GameState_descriptor();
  }
  template <typename T>
  static inline const std::string& GameState_Name(T value) {
    return Board_GameState_Name(value);
  }
  static inline bool GameState_Parse(absl::string_view name, GameState* value) {
    return Board_GameState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFlatFieldsFieldNumber = 4,
    kScoreFieldNumber = 5,
    kResourcesFieldNumber = 6,
    kTurnFieldNumber = 1,
    kMoveFieldNumber = 2,
    kLastRevealedFieldNumber = 3,
    kStateFieldNumber = 7,
  };
  // repeated .hexzpb.Field flat_fields = 4;
  int flat_fields_size() const;
  private:
  int _internal_flat_fields_size() const;

  public:
  void clear_flat_fields() ;
  ::hexzpb::Field* mutable_flat_fields(int index);
  ::google::protobuf::RepeatedPtrField< ::hexzpb::Field >*
      mutable_flat_fields();
  private:
  const ::google::protobuf::RepeatedPtrField<::hexzpb::Field>& _internal_flat_fields() const;
  ::google::protobuf::RepeatedPtrField<::hexzpb::Field>* _internal_mutable_flat_fields();
  public:
  const ::hexzpb::Field& flat_fields(int index) const;
  ::hexzpb::Field* add_flat_fields();
  const ::google::protobuf::RepeatedPtrField< ::hexzpb::Field >&
      flat_fields() const;
  // repeated int32 score = 5;
  int score_size() const;
  private:
  int _internal_score_size() const;

  public:
  void clear_score() ;
  ::int32_t score(int index) const;
  void set_score(int index, ::int32_t value);
  void add_score(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& score() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_score();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_score() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_score();

  public:
  // repeated .hexzpb.ResourceInfo resources = 6;
  int resources_size() const;
  private:
  int _internal_resources_size() const;

  public:
  void clear_resources() ;
  ::hexzpb::ResourceInfo* mutable_resources(int index);
  ::google::protobuf::RepeatedPtrField< ::hexzpb::ResourceInfo >*
      mutable_resources();
  private:
  const ::google::protobuf::RepeatedPtrField<::hexzpb::ResourceInfo>& _internal_resources() const;
  ::google::protobuf::RepeatedPtrField<::hexzpb::ResourceInfo>* _internal_mutable_resources();
  public:
  const ::hexzpb::ResourceInfo& resources(int index) const;
  ::hexzpb::ResourceInfo* add_resources();
  const ::google::protobuf::RepeatedPtrField< ::hexzpb::ResourceInfo >&
      resources() const;
  // int32 turn = 1;
  void clear_turn() ;
  ::int32_t turn() const;
  void set_turn(::int32_t value);

  private:
  ::int32_t _internal_turn() const;
  void _internal_set_turn(::int32_t value);

  public:
  // int32 move = 2;
  void clear_move() ;
  ::int32_t move() const;
  void set_move(::int32_t value);

  private:
  ::int32_t _internal_move() const;
  void _internal_set_move(::int32_t value);

  public:
  // int32 last_revealed = 3;
  void clear_last_revealed() ;
  ::int32_t last_revealed() const;
  void set_last_revealed(::int32_t value);

  private:
  ::int32_t _internal_last_revealed() const;
  void _internal_set_last_revealed(::int32_t value);

  public:
  // .hexzpb.Board.GameState state = 7;
  void clear_state() ;
  ::hexzpb::Board_GameState state() const;
  void set_state(::hexzpb::Board_GameState value);

  private:
  ::hexzpb::Board_GameState _internal_state() const;
  void _internal_set_state(::hexzpb::Board_GameState value);

  public:
  // @@protoc_insertion_point(class_scope:hexzpb.Board)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::hexzpb::Field > flat_fields_;
    ::google::protobuf::RepeatedField<::int32_t> score_;
    mutable ::google::protobuf::internal::CachedSize _score_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField< ::hexzpb::ResourceInfo > resources_;
    ::int32_t turn_;
    ::int32_t move_;
    ::int32_t last_revealed_;
    int state_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hexz_2eproto;
};// -------------------------------------------------------------------

class Field final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hexzpb.Field) */ {
 public:
  inline Field() : Field(nullptr) {}
  ~Field() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Field(::google::protobuf::internal::ConstantInitialized);

  Field(const Field& from);
  Field(Field&& from) noexcept
    : Field() {
    *this = ::std::move(from);
  }

  inline Field& operator=(const Field& from) {
    CopyFrom(from);
    return *this;
  }
  inline Field& operator=(Field&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Field& default_instance() {
    return *internal_default_instance();
  }
  static inline const Field* internal_default_instance() {
    return reinterpret_cast<const Field*>(
               &_Field_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Field& a, Field& b) {
    a.Swap(&b);
  }
  inline void Swap(Field* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Field* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Field* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Field>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Field& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Field& from) {
    Field::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Field* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hexzpb.Field";
  }
  protected:
  explicit Field(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using CellType = Field_CellType;
  static constexpr CellType NORMAL = Field_CellType_NORMAL;
  static constexpr CellType DEAD = Field_CellType_DEAD;
  static constexpr CellType GRASS = Field_CellType_GRASS;
  static constexpr CellType ROCK = Field_CellType_ROCK;
  static constexpr CellType FIRE = Field_CellType_FIRE;
  static constexpr CellType FLAG = Field_CellType_FLAG;
  static constexpr CellType PEST = Field_CellType_PEST;
  static constexpr CellType DEATH = Field_CellType_DEATH;
  static inline bool CellType_IsValid(int value) {
    return Field_CellType_IsValid(value);
  }
  static constexpr CellType CellType_MIN = Field_CellType_CellType_MIN;
  static constexpr CellType CellType_MAX = Field_CellType_CellType_MAX;
  static constexpr int CellType_ARRAYSIZE = Field_CellType_CellType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* CellType_descriptor() {
    return Field_CellType_descriptor();
  }
  template <typename T>
  static inline const std::string& CellType_Name(T value) {
    return Field_CellType_Name(value);
  }
  static inline bool CellType_Parse(absl::string_view name, CellType* value) {
    return Field_CellType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNextValFieldNumber = 7,
    kTypeFieldNumber = 1,
    kOwnerFieldNumber = 2,
    kHiddenFieldNumber = 3,
    kValueFieldNumber = 4,
    kBlockedFieldNumber = 5,
    kLifetimeFieldNumber = 6,
  };
  // repeated int32 next_val = 7;
  int next_val_size() const;
  private:
  int _internal_next_val_size() const;

  public:
  void clear_next_val() ;
  ::int32_t next_val(int index) const;
  void set_next_val(int index, ::int32_t value);
  void add_next_val(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& next_val() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_next_val();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_next_val() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_next_val();

  public:
  // .hexzpb.Field.CellType type = 1;
  void clear_type() ;
  ::hexzpb::Field_CellType type() const;
  void set_type(::hexzpb::Field_CellType value);

  private:
  ::hexzpb::Field_CellType _internal_type() const;
  void _internal_set_type(::hexzpb::Field_CellType value);

  public:
  // int32 owner = 2;
  void clear_owner() ;
  ::int32_t owner() const;
  void set_owner(::int32_t value);

  private:
  ::int32_t _internal_owner() const;
  void _internal_set_owner(::int32_t value);

  public:
  // bool hidden = 3;
  void clear_hidden() ;
  bool hidden() const;
  void set_hidden(bool value);

  private:
  bool _internal_hidden() const;
  void _internal_set_hidden(bool value);

  public:
  // int32 value = 4;
  void clear_value() ;
  ::int32_t value() const;
  void set_value(::int32_t value);

  private:
  ::int32_t _internal_value() const;
  void _internal_set_value(::int32_t value);

  public:
  // int32 blocked = 5;
  void clear_blocked() ;
  ::int32_t blocked() const;
  void set_blocked(::int32_t value);

  private:
  ::int32_t _internal_blocked() const;
  void _internal_set_blocked(::int32_t value);

  public:
  // int32 lifetime = 6;
  void clear_lifetime() ;
  ::int32_t lifetime() const;
  void set_lifetime(::int32_t value);

  private:
  ::int32_t _internal_lifetime() const;
  void _internal_set_lifetime(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:hexzpb.Field)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedField<::int32_t> next_val_;
    mutable ::google::protobuf::internal::CachedSize _next_val_cached_byte_size_;
    int type_;
    ::int32_t owner_;
    bool hidden_;
    ::int32_t value_;
    ::int32_t blocked_;
    ::int32_t lifetime_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hexz_2eproto;
};// -------------------------------------------------------------------

class ResourceInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hexzpb.ResourceInfo) */ {
 public:
  inline ResourceInfo() : ResourceInfo(nullptr) {}
  ~ResourceInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResourceInfo(::google::protobuf::internal::ConstantInitialized);

  ResourceInfo(const ResourceInfo& from);
  ResourceInfo(ResourceInfo&& from) noexcept
    : ResourceInfo() {
    *this = ::std::move(from);
  }

  inline ResourceInfo& operator=(const ResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceInfo& operator=(ResourceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceInfo* internal_default_instance() {
    return reinterpret_cast<const ResourceInfo*>(
               &_ResourceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ResourceInfo& a, ResourceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResourceInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResourceInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ResourceInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ResourceInfo& from) {
    ResourceInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hexzpb.ResourceInfo";
  }
  protected:
  explicit ResourceInfo(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumPiecesFieldNumber = 1,
  };
  // repeated int32 num_pieces = 1;
  int num_pieces_size() const;
  private:
  int _internal_num_pieces_size() const;

  public:
  void clear_num_pieces() ;
  ::int32_t num_pieces(int index) const;
  void set_num_pieces(int index, ::int32_t value);
  void add_num_pieces(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& num_pieces() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_num_pieces();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_num_pieces() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_num_pieces();

  public:
  // @@protoc_insertion_point(class_scope:hexzpb.ResourceInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedField<::int32_t> num_pieces_;
    mutable ::google::protobuf::internal::CachedSize _num_pieces_cached_byte_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hexz_2eproto;
};// -------------------------------------------------------------------

class Player final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hexzpb.Player) */ {
 public:
  inline Player() : Player(nullptr) {}
  ~Player() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Player(::google::protobuf::internal::ConstantInitialized);

  Player(const Player& from);
  Player(Player&& from) noexcept
    : Player() {
    *this = ::std::move(from);
  }

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }
  inline Player& operator=(Player&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Player& default_instance() {
    return *internal_default_instance();
  }
  static inline const Player* internal_default_instance() {
    return reinterpret_cast<const Player*>(
               &_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Player& a, Player& b) {
    a.Swap(&b);
  }
  inline void Swap(Player* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Player* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Player* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Player>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Player& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Player& from) {
    Player::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hexzpb.Player";
  }
  protected:
  explicit Player(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:hexzpb.Player)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 28, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hexz_2eproto;
};// -------------------------------------------------------------------

class GameInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hexzpb.GameInfo) */ {
 public:
  inline GameInfo() : GameInfo(nullptr) {}
  ~GameInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GameInfo(::google::protobuf::internal::ConstantInitialized);

  GameInfo(const GameInfo& from);
  GameInfo(GameInfo&& from) noexcept
    : GameInfo() {
    *this = ::std::move(from);
  }

  inline GameInfo& operator=(const GameInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameInfo& operator=(GameInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameInfo* internal_default_instance() {
    return reinterpret_cast<const GameInfo*>(
               &_GameInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GameInfo& a, GameInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(GameInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GameInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GameInfo& from) {
    GameInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hexzpb.GameInfo";
  }
  protected:
  explicit GameInfo(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kHostFieldNumber = 2,
    kTypeFieldNumber = 4,
    kStartedFieldNumber = 3,
    kCpuPlayerFieldNumber = 5,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string host = 2;
  void clear_host() ;
  const std::string& host() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_host(Arg_&& arg, Args_... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* ptr);

  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(
      const std::string& value);
  std::string* _internal_mutable_host();

  public:
  // string type = 4;
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* ptr);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // .google.protobuf.Timestamp started = 3;
  bool has_started() const;
  void clear_started() ;
  const ::google::protobuf::Timestamp& started() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_started();
  ::google::protobuf::Timestamp* mutable_started();
  void set_allocated_started(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_started(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_started();

  private:
  const ::google::protobuf::Timestamp& _internal_started() const;
  ::google::protobuf::Timestamp* _internal_mutable_started();

  public:
  // bool cpu_player = 5;
  void clear_cpu_player() ;
  bool cpu_player() const;
  void set_cpu_player(bool value);

  private:
  bool _internal_cpu_player() const;
  void _internal_set_cpu_player(bool value);

  public:
  // @@protoc_insertion_point(class_scope:hexzpb.GameInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 1, 34, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr host_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::google::protobuf::Timestamp* started_;
    bool cpu_player_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hexz_2eproto;
};// -------------------------------------------------------------------

class GameState final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hexzpb.GameState) */ {
 public:
  inline GameState() : GameState(nullptr) {}
  ~GameState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GameState(::google::protobuf::internal::ConstantInitialized);

  GameState(const GameState& from);
  GameState(GameState&& from) noexcept
    : GameState() {
    *this = ::std::move(from);
  }

  inline GameState& operator=(const GameState& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameState& operator=(GameState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameState& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameState* internal_default_instance() {
    return reinterpret_cast<const GameState*>(
               &_GameState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GameState& a, GameState& b) {
    a.Swap(&b);
  }
  inline void Swap(GameState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GameState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GameState& from) {
    GameState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameState* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hexzpb.GameState";
  }
  protected:
  explicit GameState(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 5,
    kGameInfoFieldNumber = 1,
    kModifiedFieldNumber = 4,
    kEngineStateFieldNumber = 6,
    kSeqnumFieldNumber = 2,
  };
  // repeated .hexzpb.Player players = 5;
  int players_size() const;
  private:
  int _internal_players_size() const;

  public:
  void clear_players() ;
  ::hexzpb::Player* mutable_players(int index);
  ::google::protobuf::RepeatedPtrField< ::hexzpb::Player >*
      mutable_players();
  private:
  const ::google::protobuf::RepeatedPtrField<::hexzpb::Player>& _internal_players() const;
  ::google::protobuf::RepeatedPtrField<::hexzpb::Player>* _internal_mutable_players();
  public:
  const ::hexzpb::Player& players(int index) const;
  ::hexzpb::Player* add_players();
  const ::google::protobuf::RepeatedPtrField< ::hexzpb::Player >&
      players() const;
  // .hexzpb.GameInfo game_info = 1;
  bool has_game_info() const;
  void clear_game_info() ;
  const ::hexzpb::GameInfo& game_info() const;
  PROTOBUF_NODISCARD ::hexzpb::GameInfo* release_game_info();
  ::hexzpb::GameInfo* mutable_game_info();
  void set_allocated_game_info(::hexzpb::GameInfo* value);
  void unsafe_arena_set_allocated_game_info(::hexzpb::GameInfo* value);
  ::hexzpb::GameInfo* unsafe_arena_release_game_info();

  private:
  const ::hexzpb::GameInfo& _internal_game_info() const;
  ::hexzpb::GameInfo* _internal_mutable_game_info();

  public:
  // .google.protobuf.Timestamp modified = 4;
  bool has_modified() const;
  void clear_modified() ;
  const ::google::protobuf::Timestamp& modified() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_modified();
  ::google::protobuf::Timestamp* mutable_modified();
  void set_allocated_modified(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_modified(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_modified();

  private:
  const ::google::protobuf::Timestamp& _internal_modified() const;
  ::google::protobuf::Timestamp* _internal_mutable_modified();

  public:
  // .hexzpb.GameEngineState engine_state = 6;
  bool has_engine_state() const;
  void clear_engine_state() ;
  const ::hexzpb::GameEngineState& engine_state() const;
  PROTOBUF_NODISCARD ::hexzpb::GameEngineState* release_engine_state();
  ::hexzpb::GameEngineState* mutable_engine_state();
  void set_allocated_engine_state(::hexzpb::GameEngineState* value);
  void unsafe_arena_set_allocated_engine_state(::hexzpb::GameEngineState* value);
  ::hexzpb::GameEngineState* unsafe_arena_release_engine_state();

  private:
  const ::hexzpb::GameEngineState& _internal_engine_state() const;
  ::hexzpb::GameEngineState* _internal_mutable_engine_state();

  public:
  // int64 seqnum = 2;
  void clear_seqnum() ;
  ::int64_t seqnum() const;
  void set_seqnum(::int64_t value);

  private:
  ::int64_t _internal_seqnum() const;
  void _internal_set_seqnum(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:hexzpb.GameState)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 4, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::hexzpb::Player > players_;
    ::hexzpb::GameInfo* game_info_;
    ::google::protobuf::Timestamp* modified_;
    ::hexzpb::GameEngineState* engine_state_;
    ::int64_t seqnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hexz_2eproto;
};// -------------------------------------------------------------------

class GameEngineState final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hexzpb.GameEngineState) */ {
 public:
  inline GameEngineState() : GameEngineState(nullptr) {}
  ~GameEngineState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GameEngineState(::google::protobuf::internal::ConstantInitialized);

  GameEngineState(const GameEngineState& from);
  GameEngineState(GameEngineState&& from) noexcept
    : GameEngineState() {
    *this = ::std::move(from);
  }

  inline GameEngineState& operator=(const GameEngineState& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameEngineState& operator=(GameEngineState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameEngineState& default_instance() {
    return *internal_default_instance();
  }
  enum StateCase {
    kFlagz = 1,
    kClassic = 2,
    kFreeform = 3,
    STATE_NOT_SET = 0,
  };

  static inline const GameEngineState* internal_default_instance() {
    return reinterpret_cast<const GameEngineState*>(
               &_GameEngineState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GameEngineState& a, GameEngineState& b) {
    a.Swap(&b);
  }
  inline void Swap(GameEngineState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameEngineState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameEngineState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameEngineState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GameEngineState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GameEngineState& from) {
    GameEngineState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameEngineState* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hexzpb.GameEngineState";
  }
  protected:
  explicit GameEngineState(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlagzFieldNumber = 1,
    kClassicFieldNumber = 2,
    kFreeformFieldNumber = 3,
  };
  // .hexzpb.GameEngineFlagzState flagz = 1;
  bool has_flagz() const;
  private:
  bool _internal_has_flagz() const;

  public:
  void clear_flagz() ;
  const ::hexzpb::GameEngineFlagzState& flagz() const;
  PROTOBUF_NODISCARD ::hexzpb::GameEngineFlagzState* release_flagz();
  ::hexzpb::GameEngineFlagzState* mutable_flagz();
  void set_allocated_flagz(::hexzpb::GameEngineFlagzState* value);
  void unsafe_arena_set_allocated_flagz(::hexzpb::GameEngineFlagzState* value);
  ::hexzpb::GameEngineFlagzState* unsafe_arena_release_flagz();

  private:
  const ::hexzpb::GameEngineFlagzState& _internal_flagz() const;
  ::hexzpb::GameEngineFlagzState* _internal_mutable_flagz();

  public:
  // .hexzpb.GameEngineClassicState classic = 2;
  bool has_classic() const;
  private:
  bool _internal_has_classic() const;

  public:
  void clear_classic() ;
  const ::hexzpb::GameEngineClassicState& classic() const;
  PROTOBUF_NODISCARD ::hexzpb::GameEngineClassicState* release_classic();
  ::hexzpb::GameEngineClassicState* mutable_classic();
  void set_allocated_classic(::hexzpb::GameEngineClassicState* value);
  void unsafe_arena_set_allocated_classic(::hexzpb::GameEngineClassicState* value);
  ::hexzpb::GameEngineClassicState* unsafe_arena_release_classic();

  private:
  const ::hexzpb::GameEngineClassicState& _internal_classic() const;
  ::hexzpb::GameEngineClassicState* _internal_mutable_classic();

  public:
  // .hexzpb.GameEngineFreeformState freeform = 3;
  bool has_freeform() const;
  private:
  bool _internal_has_freeform() const;

  public:
  void clear_freeform() ;
  const ::hexzpb::GameEngineFreeformState& freeform() const;
  PROTOBUF_NODISCARD ::hexzpb::GameEngineFreeformState* release_freeform();
  ::hexzpb::GameEngineFreeformState* mutable_freeform();
  void set_allocated_freeform(::hexzpb::GameEngineFreeformState* value);
  void unsafe_arena_set_allocated_freeform(::hexzpb::GameEngineFreeformState* value);
  ::hexzpb::GameEngineFreeformState* unsafe_arena_release_freeform();

  private:
  const ::hexzpb::GameEngineFreeformState& _internal_freeform() const;
  ::hexzpb::GameEngineFreeformState* _internal_mutable_freeform();

  public:
  void clear_state();
  StateCase state_case() const;
  // @@protoc_insertion_point(class_scope:hexzpb.GameEngineState)
 private:
  class _Internal;
  void set_has_flagz();
  void set_has_classic();
  void set_has_freeform();

  inline bool has_state() const;
  inline void clear_has_state();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 3, 3, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union StateUnion {
      constexpr StateUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::hexzpb::GameEngineFlagzState* flagz_;
      ::hexzpb::GameEngineClassicState* classic_;
      ::hexzpb::GameEngineFreeformState* freeform_;
    } state_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hexz_2eproto;
};// -------------------------------------------------------------------

class GameEngineFlagzState final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hexzpb.GameEngineFlagzState) */ {
 public:
  inline GameEngineFlagzState() : GameEngineFlagzState(nullptr) {}
  ~GameEngineFlagzState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GameEngineFlagzState(::google::protobuf::internal::ConstantInitialized);

  GameEngineFlagzState(const GameEngineFlagzState& from);
  GameEngineFlagzState(GameEngineFlagzState&& from) noexcept
    : GameEngineFlagzState() {
    *this = ::std::move(from);
  }

  inline GameEngineFlagzState& operator=(const GameEngineFlagzState& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameEngineFlagzState& operator=(GameEngineFlagzState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameEngineFlagzState& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameEngineFlagzState* internal_default_instance() {
    return reinterpret_cast<const GameEngineFlagzState*>(
               &_GameEngineFlagzState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GameEngineFlagzState& a, GameEngineFlagzState& b) {
    a.Swap(&b);
  }
  inline void Swap(GameEngineFlagzState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameEngineFlagzState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameEngineFlagzState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameEngineFlagzState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GameEngineFlagzState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GameEngineFlagzState& from) {
    GameEngineFlagzState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameEngineFlagzState* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hexzpb.GameEngineFlagzState";
  }
  protected:
  explicit GameEngineFlagzState(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNormalMovesFieldNumber = 3,
    kMovesFieldNumber = 4,
    kBoardFieldNumber = 1,
    kFreeCellsFieldNumber = 2,
  };
  // repeated int32 normal_moves = 3;
  int normal_moves_size() const;
  private:
  int _internal_normal_moves_size() const;

  public:
  void clear_normal_moves() ;
  ::int32_t normal_moves(int index) const;
  void set_normal_moves(int index, ::int32_t value);
  void add_normal_moves(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& normal_moves() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_normal_moves();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_normal_moves() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_normal_moves();

  public:
  // repeated .hexzpb.GameEngineMove moves = 4;
  int moves_size() const;
  private:
  int _internal_moves_size() const;

  public:
  void clear_moves() ;
  ::hexzpb::GameEngineMove* mutable_moves(int index);
  ::google::protobuf::RepeatedPtrField< ::hexzpb::GameEngineMove >*
      mutable_moves();
  private:
  const ::google::protobuf::RepeatedPtrField<::hexzpb::GameEngineMove>& _internal_moves() const;
  ::google::protobuf::RepeatedPtrField<::hexzpb::GameEngineMove>* _internal_mutable_moves();
  public:
  const ::hexzpb::GameEngineMove& moves(int index) const;
  ::hexzpb::GameEngineMove* add_moves();
  const ::google::protobuf::RepeatedPtrField< ::hexzpb::GameEngineMove >&
      moves() const;
  // .hexzpb.Board board = 1;
  bool has_board() const;
  void clear_board() ;
  const ::hexzpb::Board& board() const;
  PROTOBUF_NODISCARD ::hexzpb::Board* release_board();
  ::hexzpb::Board* mutable_board();
  void set_allocated_board(::hexzpb::Board* value);
  void unsafe_arena_set_allocated_board(::hexzpb::Board* value);
  ::hexzpb::Board* unsafe_arena_release_board();

  private:
  const ::hexzpb::Board& _internal_board() const;
  ::hexzpb::Board* _internal_mutable_board();

  public:
  // int32 free_cells = 2;
  void clear_free_cells() ;
  ::int32_t free_cells() const;
  void set_free_cells(::int32_t value);

  private:
  ::int32_t _internal_free_cells() const;
  void _internal_set_free_cells(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:hexzpb.GameEngineFlagzState)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> normal_moves_;
    mutable ::google::protobuf::internal::CachedSize _normal_moves_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField< ::hexzpb::GameEngineMove > moves_;
    ::hexzpb::Board* board_;
    ::int32_t free_cells_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hexz_2eproto;
};// -------------------------------------------------------------------

class GameEngineClassicState final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hexzpb.GameEngineClassicState) */ {
 public:
  inline GameEngineClassicState() : GameEngineClassicState(nullptr) {}
  ~GameEngineClassicState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GameEngineClassicState(::google::protobuf::internal::ConstantInitialized);

  GameEngineClassicState(const GameEngineClassicState& from);
  GameEngineClassicState(GameEngineClassicState&& from) noexcept
    : GameEngineClassicState() {
    *this = ::std::move(from);
  }

  inline GameEngineClassicState& operator=(const GameEngineClassicState& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameEngineClassicState& operator=(GameEngineClassicState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameEngineClassicState& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameEngineClassicState* internal_default_instance() {
    return reinterpret_cast<const GameEngineClassicState*>(
               &_GameEngineClassicState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GameEngineClassicState& a, GameEngineClassicState& b) {
    a.Swap(&b);
  }
  inline void Swap(GameEngineClassicState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameEngineClassicState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameEngineClassicState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameEngineClassicState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GameEngineClassicState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GameEngineClassicState& from) {
    GameEngineClassicState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameEngineClassicState* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hexzpb.GameEngineClassicState";
  }
  protected:
  explicit GameEngineClassicState(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoardFieldNumber = 1,
  };
  // .hexzpb.Board board = 1;
  bool has_board() const;
  void clear_board() ;
  const ::hexzpb::Board& board() const;
  PROTOBUF_NODISCARD ::hexzpb::Board* release_board();
  ::hexzpb::Board* mutable_board();
  void set_allocated_board(::hexzpb::Board* value);
  void unsafe_arena_set_allocated_board(::hexzpb::Board* value);
  ::hexzpb::Board* unsafe_arena_release_board();

  private:
  const ::hexzpb::Board& _internal_board() const;
  ::hexzpb::Board* _internal_mutable_board();

  public:
  // @@protoc_insertion_point(class_scope:hexzpb.GameEngineClassicState)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::hexzpb::Board* board_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hexz_2eproto;
};// -------------------------------------------------------------------

class GameEngineFreeformState final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hexzpb.GameEngineFreeformState) */ {
 public:
  inline GameEngineFreeformState() : GameEngineFreeformState(nullptr) {}
  ~GameEngineFreeformState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GameEngineFreeformState(::google::protobuf::internal::ConstantInitialized);

  GameEngineFreeformState(const GameEngineFreeformState& from);
  GameEngineFreeformState(GameEngineFreeformState&& from) noexcept
    : GameEngineFreeformState() {
    *this = ::std::move(from);
  }

  inline GameEngineFreeformState& operator=(const GameEngineFreeformState& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameEngineFreeformState& operator=(GameEngineFreeformState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameEngineFreeformState& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameEngineFreeformState* internal_default_instance() {
    return reinterpret_cast<const GameEngineFreeformState*>(
               &_GameEngineFreeformState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GameEngineFreeformState& a, GameEngineFreeformState& b) {
    a.Swap(&b);
  }
  inline void Swap(GameEngineFreeformState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameEngineFreeformState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameEngineFreeformState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameEngineFreeformState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GameEngineFreeformState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GameEngineFreeformState& from) {
    GameEngineFreeformState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameEngineFreeformState* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hexzpb.GameEngineFreeformState";
  }
  protected:
  explicit GameEngineFreeformState(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoardFieldNumber = 1,
  };
  // .hexzpb.Board board = 1;
  bool has_board() const;
  void clear_board() ;
  const ::hexzpb::Board& board() const;
  PROTOBUF_NODISCARD ::hexzpb::Board* release_board();
  ::hexzpb::Board* mutable_board();
  void set_allocated_board(::hexzpb::Board* value);
  void unsafe_arena_set_allocated_board(::hexzpb::Board* value);
  ::hexzpb::Board* unsafe_arena_release_board();

  private:
  const ::hexzpb::Board& _internal_board() const;
  ::hexzpb::Board* _internal_mutable_board();

  public:
  // @@protoc_insertion_point(class_scope:hexzpb.GameEngineFreeformState)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::hexzpb::Board* board_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hexz_2eproto;
};// -------------------------------------------------------------------

class GameEngineMove final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hexzpb.GameEngineMove) */ {
 public:
  inline GameEngineMove() : GameEngineMove(nullptr) {}
  ~GameEngineMove() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GameEngineMove(::google::protobuf::internal::ConstantInitialized);

  GameEngineMove(const GameEngineMove& from);
  GameEngineMove(GameEngineMove&& from) noexcept
    : GameEngineMove() {
    *this = ::std::move(from);
  }

  inline GameEngineMove& operator=(const GameEngineMove& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameEngineMove& operator=(GameEngineMove&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameEngineMove& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameEngineMove* internal_default_instance() {
    return reinterpret_cast<const GameEngineMove*>(
               &_GameEngineMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GameEngineMove& a, GameEngineMove& b) {
    a.Swap(&b);
  }
  inline void Swap(GameEngineMove* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameEngineMove* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameEngineMove* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameEngineMove>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GameEngineMove& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GameEngineMove& from) {
    GameEngineMove::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameEngineMove* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hexzpb.GameEngineMove";
  }
  protected:
  explicit GameEngineMove(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerNumFieldNumber = 1,
    kMoveFieldNumber = 2,
    kRowFieldNumber = 3,
    kColFieldNumber = 4,
    kCellTypeFieldNumber = 5,
  };
  // int32 player_num = 1;
  void clear_player_num() ;
  ::int32_t player_num() const;
  void set_player_num(::int32_t value);

  private:
  ::int32_t _internal_player_num() const;
  void _internal_set_player_num(::int32_t value);

  public:
  // int32 move = 2;
  void clear_move() ;
  ::int32_t move() const;
  void set_move(::int32_t value);

  private:
  ::int32_t _internal_move() const;
  void _internal_set_move(::int32_t value);

  public:
  // int32 row = 3;
  void clear_row() ;
  ::int32_t row() const;
  void set_row(::int32_t value);

  private:
  ::int32_t _internal_row() const;
  void _internal_set_row(::int32_t value);

  public:
  // int32 col = 4;
  void clear_col() ;
  ::int32_t col() const;
  void set_col(::int32_t value);

  private:
  ::int32_t _internal_col() const;
  void _internal_set_col(::int32_t value);

  public:
  // .hexzpb.Field.CellType cell_type = 5;
  void clear_cell_type() ;
  ::hexzpb::Field_CellType cell_type() const;
  void set_cell_type(::hexzpb::Field_CellType value);

  private:
  ::hexzpb::Field_CellType _internal_cell_type() const;
  void _internal_set_cell_type(::hexzpb::Field_CellType value);

  public:
  // @@protoc_insertion_point(class_scope:hexzpb.GameEngineMove)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t player_num_;
    ::int32_t move_;
    ::int32_t row_;
    ::int32_t col_;
    int cell_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hexz_2eproto;
};// -------------------------------------------------------------------

class MCTSExample_MoveStats final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hexzpb.MCTSExample.MoveStats) */ {
 public:
  inline MCTSExample_MoveStats() : MCTSExample_MoveStats(nullptr) {}
  ~MCTSExample_MoveStats() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MCTSExample_MoveStats(::google::protobuf::internal::ConstantInitialized);

  MCTSExample_MoveStats(const MCTSExample_MoveStats& from);
  MCTSExample_MoveStats(MCTSExample_MoveStats&& from) noexcept
    : MCTSExample_MoveStats() {
    *this = ::std::move(from);
  }

  inline MCTSExample_MoveStats& operator=(const MCTSExample_MoveStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline MCTSExample_MoveStats& operator=(MCTSExample_MoveStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MCTSExample_MoveStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const MCTSExample_MoveStats* internal_default_instance() {
    return reinterpret_cast<const MCTSExample_MoveStats*>(
               &_MCTSExample_MoveStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(MCTSExample_MoveStats& a, MCTSExample_MoveStats& b) {
    a.Swap(&b);
  }
  inline void Swap(MCTSExample_MoveStats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MCTSExample_MoveStats* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MCTSExample_MoveStats* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MCTSExample_MoveStats>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MCTSExample_MoveStats& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MCTSExample_MoveStats& from) {
    MCTSExample_MoveStats::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MCTSExample_MoveStats* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hexzpb.MCTSExample.MoveStats";
  }
  protected:
  explicit MCTSExample_MoveStats(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMoveFieldNumber = 1,
    kVisitsFieldNumber = 2,
    kWinRateFieldNumber = 3,
  };
  // .hexzpb.GameEngineMove move = 1;
  bool has_move() const;
  void clear_move() ;
  const ::hexzpb::GameEngineMove& move() const;
  PROTOBUF_NODISCARD ::hexzpb::GameEngineMove* release_move();
  ::hexzpb::GameEngineMove* mutable_move();
  void set_allocated_move(::hexzpb::GameEngineMove* value);
  void unsafe_arena_set_allocated_move(::hexzpb::GameEngineMove* value);
  ::hexzpb::GameEngineMove* unsafe_arena_release_move();

  private:
  const ::hexzpb::GameEngineMove& _internal_move() const;
  ::hexzpb::GameEngineMove* _internal_mutable_move();

  public:
  // int32 visits = 2;
  void clear_visits() ;
  ::int32_t visits() const;
  void set_visits(::int32_t value);

  private:
  ::int32_t _internal_visits() const;
  void _internal_set_visits(::int32_t value);

  public:
  // float win_rate = 3;
  void clear_win_rate() ;
  float win_rate() const;
  void set_win_rate(float value);

  private:
  float _internal_win_rate() const;
  void _internal_set_win_rate(float value);

  public:
  // @@protoc_insertion_point(class_scope:hexzpb.MCTSExample.MoveStats)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::hexzpb::GameEngineMove* move_;
    ::int32_t visits_;
    float win_rate_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hexz_2eproto;
};// -------------------------------------------------------------------

class MCTSExample final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hexzpb.MCTSExample) */ {
 public:
  inline MCTSExample() : MCTSExample(nullptr) {}
  ~MCTSExample() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MCTSExample(::google::protobuf::internal::ConstantInitialized);

  MCTSExample(const MCTSExample& from);
  MCTSExample(MCTSExample&& from) noexcept
    : MCTSExample() {
    *this = ::std::move(from);
  }

  inline MCTSExample& operator=(const MCTSExample& from) {
    CopyFrom(from);
    return *this;
  }
  inline MCTSExample& operator=(MCTSExample&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MCTSExample& default_instance() {
    return *internal_default_instance();
  }
  static inline const MCTSExample* internal_default_instance() {
    return reinterpret_cast<const MCTSExample*>(
               &_MCTSExample_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(MCTSExample& a, MCTSExample& b) {
    a.Swap(&b);
  }
  inline void Swap(MCTSExample* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MCTSExample* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MCTSExample* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MCTSExample>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MCTSExample& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MCTSExample& from) {
    MCTSExample::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MCTSExample* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hexzpb.MCTSExample";
  }
  protected:
  explicit MCTSExample(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MCTSExample_MoveStats MoveStats;

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 3,
    kMoveStatsFieldNumber = 4,
    kGameIdFieldNumber = 1,
    kBoardFieldNumber = 2,
  };
  // repeated int32 result = 3;
  int result_size() const;
  private:
  int _internal_result_size() const;

  public:
  void clear_result() ;
  ::int32_t result(int index) const;
  void set_result(int index, ::int32_t value);
  void add_result(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& result() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_result();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_result() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_result();

  public:
  // repeated .hexzpb.MCTSExample.MoveStats move_stats = 4;
  int move_stats_size() const;
  private:
  int _internal_move_stats_size() const;

  public:
  void clear_move_stats() ;
  ::hexzpb::MCTSExample_MoveStats* mutable_move_stats(int index);
  ::google::protobuf::RepeatedPtrField< ::hexzpb::MCTSExample_MoveStats >*
      mutable_move_stats();
  private:
  const ::google::protobuf::RepeatedPtrField<::hexzpb::MCTSExample_MoveStats>& _internal_move_stats() const;
  ::google::protobuf::RepeatedPtrField<::hexzpb::MCTSExample_MoveStats>* _internal_mutable_move_stats();
  public:
  const ::hexzpb::MCTSExample_MoveStats& move_stats(int index) const;
  ::hexzpb::MCTSExample_MoveStats* add_move_stats();
  const ::google::protobuf::RepeatedPtrField< ::hexzpb::MCTSExample_MoveStats >&
      move_stats() const;
  // string game_id = 1;
  void clear_game_id() ;
  const std::string& game_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_game_id(Arg_&& arg, Args_... args);
  std::string* mutable_game_id();
  PROTOBUF_NODISCARD std::string* release_game_id();
  void set_allocated_game_id(std::string* ptr);

  private:
  const std::string& _internal_game_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_id(
      const std::string& value);
  std::string* _internal_mutable_game_id();

  public:
  // .hexzpb.Board board = 2;
  bool has_board() const;
  void clear_board() ;
  const ::hexzpb::Board& board() const;
  PROTOBUF_NODISCARD ::hexzpb::Board* release_board();
  ::hexzpb::Board* mutable_board();
  void set_allocated_board(::hexzpb::Board* value);
  void unsafe_arena_set_allocated_board(::hexzpb::Board* value);
  ::hexzpb::Board* unsafe_arena_release_board();

  private:
  const ::hexzpb::Board& _internal_board() const;
  ::hexzpb::Board* _internal_mutable_board();

  public:
  // @@protoc_insertion_point(class_scope:hexzpb.MCTSExample)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 2, 34, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> result_;
    mutable ::google::protobuf::internal::CachedSize _result_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField< ::hexzpb::MCTSExample_MoveStats > move_stats_;
    ::google::protobuf::internal::ArenaStringPtr game_id_;
    ::hexzpb::Board* board_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hexz_2eproto;
};// -------------------------------------------------------------------

class SuggestMoveRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hexzpb.SuggestMoveRequest) */ {
 public:
  inline SuggestMoveRequest() : SuggestMoveRequest(nullptr) {}
  ~SuggestMoveRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SuggestMoveRequest(::google::protobuf::internal::ConstantInitialized);

  SuggestMoveRequest(const SuggestMoveRequest& from);
  SuggestMoveRequest(SuggestMoveRequest&& from) noexcept
    : SuggestMoveRequest() {
    *this = ::std::move(from);
  }

  inline SuggestMoveRequest& operator=(const SuggestMoveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SuggestMoveRequest& operator=(SuggestMoveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SuggestMoveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SuggestMoveRequest* internal_default_instance() {
    return reinterpret_cast<const SuggestMoveRequest*>(
               &_SuggestMoveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SuggestMoveRequest& a, SuggestMoveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SuggestMoveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SuggestMoveRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SuggestMoveRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SuggestMoveRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SuggestMoveRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SuggestMoveRequest& from) {
    SuggestMoveRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SuggestMoveRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hexzpb.SuggestMoveRequest";
  }
  protected:
  explicit SuggestMoveRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameEngineStateFieldNumber = 2,
    kMaxThinkTimeMsFieldNumber = 1,
  };
  // .hexzpb.GameEngineState game_engine_state = 2;
  bool has_game_engine_state() const;
  void clear_game_engine_state() ;
  const ::hexzpb::GameEngineState& game_engine_state() const;
  PROTOBUF_NODISCARD ::hexzpb::GameEngineState* release_game_engine_state();
  ::hexzpb::GameEngineState* mutable_game_engine_state();
  void set_allocated_game_engine_state(::hexzpb::GameEngineState* value);
  void unsafe_arena_set_allocated_game_engine_state(::hexzpb::GameEngineState* value);
  ::hexzpb::GameEngineState* unsafe_arena_release_game_engine_state();

  private:
  const ::hexzpb::GameEngineState& _internal_game_engine_state() const;
  ::hexzpb::GameEngineState* _internal_mutable_game_engine_state();

  public:
  // int64 max_think_time_ms = 1;
  void clear_max_think_time_ms() ;
  ::int64_t max_think_time_ms() const;
  void set_max_think_time_ms(::int64_t value);

  private:
  ::int64_t _internal_max_think_time_ms() const;
  void _internal_set_max_think_time_ms(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:hexzpb.SuggestMoveRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::hexzpb::GameEngineState* game_engine_state_;
    ::int64_t max_think_time_ms_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hexz_2eproto;
};// -------------------------------------------------------------------

class SuggestMoveStats_Score final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hexzpb.SuggestMoveStats.Score) */ {
 public:
  inline SuggestMoveStats_Score() : SuggestMoveStats_Score(nullptr) {}
  ~SuggestMoveStats_Score() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SuggestMoveStats_Score(::google::protobuf::internal::ConstantInitialized);

  SuggestMoveStats_Score(const SuggestMoveStats_Score& from);
  SuggestMoveStats_Score(SuggestMoveStats_Score&& from) noexcept
    : SuggestMoveStats_Score() {
    *this = ::std::move(from);
  }

  inline SuggestMoveStats_Score& operator=(const SuggestMoveStats_Score& from) {
    CopyFrom(from);
    return *this;
  }
  inline SuggestMoveStats_Score& operator=(SuggestMoveStats_Score&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SuggestMoveStats_Score& default_instance() {
    return *internal_default_instance();
  }
  static inline const SuggestMoveStats_Score* internal_default_instance() {
    return reinterpret_cast<const SuggestMoveStats_Score*>(
               &_SuggestMoveStats_Score_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SuggestMoveStats_Score& a, SuggestMoveStats_Score& b) {
    a.Swap(&b);
  }
  inline void Swap(SuggestMoveStats_Score* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SuggestMoveStats_Score* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SuggestMoveStats_Score* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SuggestMoveStats_Score>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SuggestMoveStats_Score& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SuggestMoveStats_Score& from) {
    SuggestMoveStats_Score::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SuggestMoveStats_Score* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hexzpb.SuggestMoveStats.Score";
  }
  protected:
  explicit SuggestMoveStats_Score(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKindFieldNumber = 1,
    kScoreFieldNumber = 2,
  };
  // .hexzpb.SuggestMoveStats.ScoreKind kind = 1;
  void clear_kind() ;
  ::hexzpb::SuggestMoveStats_ScoreKind kind() const;
  void set_kind(::hexzpb::SuggestMoveStats_ScoreKind value);

  private:
  ::hexzpb::SuggestMoveStats_ScoreKind _internal_kind() const;
  void _internal_set_kind(::hexzpb::SuggestMoveStats_ScoreKind value);

  public:
  // float score = 2;
  void clear_score() ;
  float score() const;
  void set_score(float value);

  private:
  float _internal_score() const;
  void _internal_set_score(float value);

  public:
  // @@protoc_insertion_point(class_scope:hexzpb.SuggestMoveStats.Score)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int kind_;
    float score_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hexz_2eproto;
};// -------------------------------------------------------------------

class SuggestMoveStats_ScoredMove final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hexzpb.SuggestMoveStats.ScoredMove) */ {
 public:
  inline SuggestMoveStats_ScoredMove() : SuggestMoveStats_ScoredMove(nullptr) {}
  ~SuggestMoveStats_ScoredMove() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SuggestMoveStats_ScoredMove(::google::protobuf::internal::ConstantInitialized);

  SuggestMoveStats_ScoredMove(const SuggestMoveStats_ScoredMove& from);
  SuggestMoveStats_ScoredMove(SuggestMoveStats_ScoredMove&& from) noexcept
    : SuggestMoveStats_ScoredMove() {
    *this = ::std::move(from);
  }

  inline SuggestMoveStats_ScoredMove& operator=(const SuggestMoveStats_ScoredMove& from) {
    CopyFrom(from);
    return *this;
  }
  inline SuggestMoveStats_ScoredMove& operator=(SuggestMoveStats_ScoredMove&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SuggestMoveStats_ScoredMove& default_instance() {
    return *internal_default_instance();
  }
  static inline const SuggestMoveStats_ScoredMove* internal_default_instance() {
    return reinterpret_cast<const SuggestMoveStats_ScoredMove*>(
               &_SuggestMoveStats_ScoredMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SuggestMoveStats_ScoredMove& a, SuggestMoveStats_ScoredMove& b) {
    a.Swap(&b);
  }
  inline void Swap(SuggestMoveStats_ScoredMove* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SuggestMoveStats_ScoredMove* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SuggestMoveStats_ScoredMove* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SuggestMoveStats_ScoredMove>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SuggestMoveStats_ScoredMove& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SuggestMoveStats_ScoredMove& from) {
    SuggestMoveStats_ScoredMove::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SuggestMoveStats_ScoredMove* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hexzpb.SuggestMoveStats.ScoredMove";
  }
  protected:
  explicit SuggestMoveStats_ScoredMove(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScoresFieldNumber = 4,
    kRowFieldNumber = 1,
    kColFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // repeated .hexzpb.SuggestMoveStats.Score scores = 4;
  int scores_size() const;
  private:
  int _internal_scores_size() const;

  public:
  void clear_scores() ;
  ::hexzpb::SuggestMoveStats_Score* mutable_scores(int index);
  ::google::protobuf::RepeatedPtrField< ::hexzpb::SuggestMoveStats_Score >*
      mutable_scores();
  private:
  const ::google::protobuf::RepeatedPtrField<::hexzpb::SuggestMoveStats_Score>& _internal_scores() const;
  ::google::protobuf::RepeatedPtrField<::hexzpb::SuggestMoveStats_Score>* _internal_mutable_scores();
  public:
  const ::hexzpb::SuggestMoveStats_Score& scores(int index) const;
  ::hexzpb::SuggestMoveStats_Score* add_scores();
  const ::google::protobuf::RepeatedPtrField< ::hexzpb::SuggestMoveStats_Score >&
      scores() const;
  // int32 row = 1;
  void clear_row() ;
  ::int32_t row() const;
  void set_row(::int32_t value);

  private:
  ::int32_t _internal_row() const;
  void _internal_set_row(::int32_t value);

  public:
  // int32 col = 2;
  void clear_col() ;
  ::int32_t col() const;
  void set_col(::int32_t value);

  private:
  ::int32_t _internal_col() const;
  void _internal_set_col(::int32_t value);

  public:
  // .hexzpb.Field.CellType type = 3;
  void clear_type() ;
  ::hexzpb::Field_CellType type() const;
  void set_type(::hexzpb::Field_CellType value);

  private:
  ::hexzpb::Field_CellType _internal_type() const;
  void _internal_set_type(::hexzpb::Field_CellType value);

  public:
  // @@protoc_insertion_point(class_scope:hexzpb.SuggestMoveStats.ScoredMove)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::hexzpb::SuggestMoveStats_Score > scores_;
    ::int32_t row_;
    ::int32_t col_;
    int type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hexz_2eproto;
};// -------------------------------------------------------------------

class SuggestMoveStats final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hexzpb.SuggestMoveStats) */ {
 public:
  inline SuggestMoveStats() : SuggestMoveStats(nullptr) {}
  ~SuggestMoveStats() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SuggestMoveStats(::google::protobuf::internal::ConstantInitialized);

  SuggestMoveStats(const SuggestMoveStats& from);
  SuggestMoveStats(SuggestMoveStats&& from) noexcept
    : SuggestMoveStats() {
    *this = ::std::move(from);
  }

  inline SuggestMoveStats& operator=(const SuggestMoveStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline SuggestMoveStats& operator=(SuggestMoveStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SuggestMoveStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const SuggestMoveStats* internal_default_instance() {
    return reinterpret_cast<const SuggestMoveStats*>(
               &_SuggestMoveStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SuggestMoveStats& a, SuggestMoveStats& b) {
    a.Swap(&b);
  }
  inline void Swap(SuggestMoveStats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SuggestMoveStats* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SuggestMoveStats* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SuggestMoveStats>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SuggestMoveStats& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SuggestMoveStats& from) {
    SuggestMoveStats::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SuggestMoveStats* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hexzpb.SuggestMoveStats";
  }
  protected:
  explicit SuggestMoveStats(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SuggestMoveStats_Score Score;
  typedef SuggestMoveStats_ScoredMove ScoredMove;

  using ScoreKind = SuggestMoveStats_ScoreKind;
  static constexpr ScoreKind FINAL = SuggestMoveStats_ScoreKind_FINAL;
  static constexpr ScoreKind MCTS_PRIOR = SuggestMoveStats_ScoreKind_MCTS_PRIOR;
  static inline bool ScoreKind_IsValid(int value) {
    return SuggestMoveStats_ScoreKind_IsValid(value);
  }
  static constexpr ScoreKind ScoreKind_MIN = SuggestMoveStats_ScoreKind_ScoreKind_MIN;
  static constexpr ScoreKind ScoreKind_MAX = SuggestMoveStats_ScoreKind_ScoreKind_MAX;
  static constexpr int ScoreKind_ARRAYSIZE = SuggestMoveStats_ScoreKind_ScoreKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ScoreKind_descriptor() {
    return SuggestMoveStats_ScoreKind_descriptor();
  }
  template <typename T>
  static inline const std::string& ScoreKind_Name(T value) {
    return SuggestMoveStats_ScoreKind_Name(value);
  }
  static inline bool ScoreKind_Parse(absl::string_view name, ScoreKind* value) {
    return SuggestMoveStats_ScoreKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMovesFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // repeated .hexzpb.SuggestMoveStats.ScoredMove moves = 1;
  int moves_size() const;
  private:
  int _internal_moves_size() const;

  public:
  void clear_moves() ;
  ::hexzpb::SuggestMoveStats_ScoredMove* mutable_moves(int index);
  ::google::protobuf::RepeatedPtrField< ::hexzpb::SuggestMoveStats_ScoredMove >*
      mutable_moves();
  private:
  const ::google::protobuf::RepeatedPtrField<::hexzpb::SuggestMoveStats_ScoredMove>& _internal_moves() const;
  ::google::protobuf::RepeatedPtrField<::hexzpb::SuggestMoveStats_ScoredMove>* _internal_mutable_moves();
  public:
  const ::hexzpb::SuggestMoveStats_ScoredMove& moves(int index) const;
  ::hexzpb::SuggestMoveStats_ScoredMove* add_moves();
  const ::google::protobuf::RepeatedPtrField< ::hexzpb::SuggestMoveStats_ScoredMove >&
      moves() const;
  // float value = 2;
  void clear_value() ;
  float value() const;
  void set_value(float value);

  private:
  float _internal_value() const;
  void _internal_set_value(float value);

  public:
  // @@protoc_insertion_point(class_scope:hexzpb.SuggestMoveStats)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::hexzpb::SuggestMoveStats_ScoredMove > moves_;
    float value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hexz_2eproto;
};// -------------------------------------------------------------------

class SuggestMoveResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hexzpb.SuggestMoveResponse) */ {
 public:
  inline SuggestMoveResponse() : SuggestMoveResponse(nullptr) {}
  ~SuggestMoveResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SuggestMoveResponse(::google::protobuf::internal::ConstantInitialized);

  SuggestMoveResponse(const SuggestMoveResponse& from);
  SuggestMoveResponse(SuggestMoveResponse&& from) noexcept
    : SuggestMoveResponse() {
    *this = ::std::move(from);
  }

  inline SuggestMoveResponse& operator=(const SuggestMoveResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SuggestMoveResponse& operator=(SuggestMoveResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SuggestMoveResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SuggestMoveResponse* internal_default_instance() {
    return reinterpret_cast<const SuggestMoveResponse*>(
               &_SuggestMoveResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SuggestMoveResponse& a, SuggestMoveResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SuggestMoveResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SuggestMoveResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SuggestMoveResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SuggestMoveResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SuggestMoveResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SuggestMoveResponse& from) {
    SuggestMoveResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SuggestMoveResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hexzpb.SuggestMoveResponse";
  }
  protected:
  explicit SuggestMoveResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMoveFieldNumber = 1,
    kMoveStatsFieldNumber = 2,
  };
  // .hexzpb.GameEngineMove move = 1;
  bool has_move() const;
  void clear_move() ;
  const ::hexzpb::GameEngineMove& move() const;
  PROTOBUF_NODISCARD ::hexzpb::GameEngineMove* release_move();
  ::hexzpb::GameEngineMove* mutable_move();
  void set_allocated_move(::hexzpb::GameEngineMove* value);
  void unsafe_arena_set_allocated_move(::hexzpb::GameEngineMove* value);
  ::hexzpb::GameEngineMove* unsafe_arena_release_move();

  private:
  const ::hexzpb::GameEngineMove& _internal_move() const;
  ::hexzpb::GameEngineMove* _internal_mutable_move();

  public:
  // .hexzpb.SuggestMoveStats move_stats = 2;
  bool has_move_stats() const;
  void clear_move_stats() ;
  const ::hexzpb::SuggestMoveStats& move_stats() const;
  PROTOBUF_NODISCARD ::hexzpb::SuggestMoveStats* release_move_stats();
  ::hexzpb::SuggestMoveStats* mutable_move_stats();
  void set_allocated_move_stats(::hexzpb::SuggestMoveStats* value);
  void unsafe_arena_set_allocated_move_stats(::hexzpb::SuggestMoveStats* value);
  ::hexzpb::SuggestMoveStats* unsafe_arena_release_move_stats();

  private:
  const ::hexzpb::SuggestMoveStats& _internal_move_stats() const;
  ::hexzpb::SuggestMoveStats* _internal_mutable_move_stats();

  public:
  // @@protoc_insertion_point(class_scope:hexzpb.SuggestMoveResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::hexzpb::GameEngineMove* move_;
    ::hexzpb::SuggestMoveStats* move_stats_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hexz_2eproto;
};// -------------------------------------------------------------------

class ModelKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hexzpb.ModelKey) */ {
 public:
  inline ModelKey() : ModelKey(nullptr) {}
  ~ModelKey() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ModelKey(::google::protobuf::internal::ConstantInitialized);

  ModelKey(const ModelKey& from);
  ModelKey(ModelKey&& from) noexcept
    : ModelKey() {
    *this = ::std::move(from);
  }

  inline ModelKey& operator=(const ModelKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelKey& operator=(ModelKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelKey* internal_default_instance() {
    return reinterpret_cast<const ModelKey*>(
               &_ModelKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ModelKey& a, ModelKey& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelKey* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelKey* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelKey>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ModelKey& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ModelKey& from) {
    ModelKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelKey* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hexzpb.ModelKey";
  }
  protected:
  explicit ModelKey(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCheckpointFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // int32 checkpoint = 2;
  void clear_checkpoint() ;
  ::int32_t checkpoint() const;
  void set_checkpoint(::int32_t value);

  private:
  ::int32_t _internal_checkpoint() const;
  void _internal_set_checkpoint(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:hexzpb.ModelKey)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 28, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::int32_t checkpoint_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hexz_2eproto;
};// -------------------------------------------------------------------

class AddTrainingExamplesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hexzpb.AddTrainingExamplesRequest) */ {
 public:
  inline AddTrainingExamplesRequest() : AddTrainingExamplesRequest(nullptr) {}
  ~AddTrainingExamplesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AddTrainingExamplesRequest(::google::protobuf::internal::ConstantInitialized);

  AddTrainingExamplesRequest(const AddTrainingExamplesRequest& from);
  AddTrainingExamplesRequest(AddTrainingExamplesRequest&& from) noexcept
    : AddTrainingExamplesRequest() {
    *this = ::std::move(from);
  }

  inline AddTrainingExamplesRequest& operator=(const AddTrainingExamplesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddTrainingExamplesRequest& operator=(AddTrainingExamplesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddTrainingExamplesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddTrainingExamplesRequest* internal_default_instance() {
    return reinterpret_cast<const AddTrainingExamplesRequest*>(
               &_AddTrainingExamplesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(AddTrainingExamplesRequest& a, AddTrainingExamplesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddTrainingExamplesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddTrainingExamplesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddTrainingExamplesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddTrainingExamplesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddTrainingExamplesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AddTrainingExamplesRequest& from) {
    AddTrainingExamplesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddTrainingExamplesRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hexzpb.AddTrainingExamplesRequest";
  }
  protected:
  explicit AddTrainingExamplesRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExamplesFieldNumber = 2,
    kExecutionIdFieldNumber = 3,
    kModelKeyFieldNumber = 1,
  };
  // repeated .hexzpb.TrainingExample examples = 2;
  int examples_size() const;
  private:
  int _internal_examples_size() const;

  public:
  void clear_examples() ;
  ::hexzpb::TrainingExample* mutable_examples(int index);
  ::google::protobuf::RepeatedPtrField< ::hexzpb::TrainingExample >*
      mutable_examples();
  private:
  const ::google::protobuf::RepeatedPtrField<::hexzpb::TrainingExample>& _internal_examples() const;
  ::google::protobuf::RepeatedPtrField<::hexzpb::TrainingExample>* _internal_mutable_examples();
  public:
  const ::hexzpb::TrainingExample& examples(int index) const;
  ::hexzpb::TrainingExample* add_examples();
  const ::google::protobuf::RepeatedPtrField< ::hexzpb::TrainingExample >&
      examples() const;
  // string execution_id = 3;
  void clear_execution_id() ;
  const std::string& execution_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_execution_id(Arg_&& arg, Args_... args);
  std::string* mutable_execution_id();
  PROTOBUF_NODISCARD std::string* release_execution_id();
  void set_allocated_execution_id(std::string* ptr);

  private:
  const std::string& _internal_execution_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_id(
      const std::string& value);
  std::string* _internal_mutable_execution_id();

  public:
  // .hexzpb.ModelKey model_key = 1;
  bool has_model_key() const;
  void clear_model_key() ;
  const ::hexzpb::ModelKey& model_key() const;
  PROTOBUF_NODISCARD ::hexzpb::ModelKey* release_model_key();
  ::hexzpb::ModelKey* mutable_model_key();
  void set_allocated_model_key(::hexzpb::ModelKey* value);
  void unsafe_arena_set_allocated_model_key(::hexzpb::ModelKey* value);
  ::hexzpb::ModelKey* unsafe_arena_release_model_key();

  private:
  const ::hexzpb::ModelKey& _internal_model_key() const;
  ::hexzpb::ModelKey* _internal_mutable_model_key();

  public:
  // @@protoc_insertion_point(class_scope:hexzpb.AddTrainingExamplesRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 2, 54, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::hexzpb::TrainingExample > examples_;
    ::google::protobuf::internal::ArenaStringPtr execution_id_;
    ::hexzpb::ModelKey* model_key_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hexz_2eproto;
};// -------------------------------------------------------------------

class AddTrainingExamplesResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hexzpb.AddTrainingExamplesResponse) */ {
 public:
  inline AddTrainingExamplesResponse() : AddTrainingExamplesResponse(nullptr) {}
  ~AddTrainingExamplesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AddTrainingExamplesResponse(::google::protobuf::internal::ConstantInitialized);

  AddTrainingExamplesResponse(const AddTrainingExamplesResponse& from);
  AddTrainingExamplesResponse(AddTrainingExamplesResponse&& from) noexcept
    : AddTrainingExamplesResponse() {
    *this = ::std::move(from);
  }

  inline AddTrainingExamplesResponse& operator=(const AddTrainingExamplesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddTrainingExamplesResponse& operator=(AddTrainingExamplesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddTrainingExamplesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddTrainingExamplesResponse* internal_default_instance() {
    return reinterpret_cast<const AddTrainingExamplesResponse*>(
               &_AddTrainingExamplesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(AddTrainingExamplesResponse& a, AddTrainingExamplesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AddTrainingExamplesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddTrainingExamplesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddTrainingExamplesResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddTrainingExamplesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddTrainingExamplesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AddTrainingExamplesResponse& from) {
    AddTrainingExamplesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddTrainingExamplesResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hexzpb.AddTrainingExamplesResponse";
  }
  protected:
  explicit AddTrainingExamplesResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Status = AddTrainingExamplesResponse_Status;
  static constexpr Status STATUS_UNSPECIFIED = AddTrainingExamplesResponse_Status_STATUS_UNSPECIFIED;
  static constexpr Status ACCEPTED = AddTrainingExamplesResponse_Status_ACCEPTED;
  static constexpr Status REJECTED_WRONG_MODEL = AddTrainingExamplesResponse_Status_REJECTED_WRONG_MODEL;
  static constexpr Status REJECTED_AT_CAPACITY = AddTrainingExamplesResponse_Status_REJECTED_AT_CAPACITY;
  static constexpr Status REJECTED_OTHER = AddTrainingExamplesResponse_Status_REJECTED_OTHER;
  static inline bool Status_IsValid(int value) {
    return AddTrainingExamplesResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN = AddTrainingExamplesResponse_Status_Status_MIN;
  static constexpr Status Status_MAX = AddTrainingExamplesResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE = AddTrainingExamplesResponse_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Status_descriptor() {
    return AddTrainingExamplesResponse_Status_descriptor();
  }
  template <typename T>
  static inline const std::string& Status_Name(T value) {
    return AddTrainingExamplesResponse_Status_Name(value);
  }
  static inline bool Status_Parse(absl::string_view name, Status* value) {
    return AddTrainingExamplesResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 3,
    kLatestModelFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // string error_message = 3;
  void clear_error_message() ;
  const std::string& error_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_message(Arg_&& arg, Args_... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* ptr);

  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(
      const std::string& value);
  std::string* _internal_mutable_error_message();

  public:
  // .hexzpb.ModelKey latest_model = 2;
  bool has_latest_model() const;
  void clear_latest_model() ;
  const ::hexzpb::ModelKey& latest_model() const;
  PROTOBUF_NODISCARD ::hexzpb::ModelKey* release_latest_model();
  ::hexzpb::ModelKey* mutable_latest_model();
  void set_allocated_latest_model(::hexzpb::ModelKey* value);
  void unsafe_arena_set_allocated_latest_model(::hexzpb::ModelKey* value);
  ::hexzpb::ModelKey* unsafe_arena_release_latest_model();

  private:
  const ::hexzpb::ModelKey& _internal_latest_model() const;
  ::hexzpb::ModelKey* _internal_mutable_latest_model();

  public:
  // .hexzpb.AddTrainingExamplesResponse.Status status = 1;
  void clear_status() ;
  ::hexzpb::AddTrainingExamplesResponse_Status status() const;
  void set_status(::hexzpb::AddTrainingExamplesResponse_Status value);

  private:
  ::hexzpb::AddTrainingExamplesResponse_Status _internal_status() const;
  void _internal_set_status(::hexzpb::AddTrainingExamplesResponse_Status value);

  public:
  // @@protoc_insertion_point(class_scope:hexzpb.AddTrainingExamplesResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 1, 56, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr error_message_;
    ::hexzpb::ModelKey* latest_model_;
    int status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hexz_2eproto;
};// -------------------------------------------------------------------

class TrainingExample_ModelPredictions final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hexzpb.TrainingExample.ModelPredictions) */ {
 public:
  inline TrainingExample_ModelPredictions() : TrainingExample_ModelPredictions(nullptr) {}
  ~TrainingExample_ModelPredictions() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TrainingExample_ModelPredictions(::google::protobuf::internal::ConstantInitialized);

  TrainingExample_ModelPredictions(const TrainingExample_ModelPredictions& from);
  TrainingExample_ModelPredictions(TrainingExample_ModelPredictions&& from) noexcept
    : TrainingExample_ModelPredictions() {
    *this = ::std::move(from);
  }

  inline TrainingExample_ModelPredictions& operator=(const TrainingExample_ModelPredictions& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrainingExample_ModelPredictions& operator=(TrainingExample_ModelPredictions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrainingExample_ModelPredictions& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrainingExample_ModelPredictions* internal_default_instance() {
    return reinterpret_cast<const TrainingExample_ModelPredictions*>(
               &_TrainingExample_ModelPredictions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(TrainingExample_ModelPredictions& a, TrainingExample_ModelPredictions& b) {
    a.Swap(&b);
  }
  inline void Swap(TrainingExample_ModelPredictions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrainingExample_ModelPredictions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrainingExample_ModelPredictions* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrainingExample_ModelPredictions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrainingExample_ModelPredictions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TrainingExample_ModelPredictions& from) {
    TrainingExample_ModelPredictions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrainingExample_ModelPredictions* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hexzpb.TrainingExample.ModelPredictions";
  }
  protected:
  explicit TrainingExample_ModelPredictions(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPriorsFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // bytes priors = 1;
  void clear_priors() ;
  const std::string& priors() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_priors(Arg_&& arg, Args_... args);
  std::string* mutable_priors();
  PROTOBUF_NODISCARD std::string* release_priors();
  void set_allocated_priors(std::string* ptr);

  private:
  const std::string& _internal_priors() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_priors(
      const std::string& value);
  std::string* _internal_mutable_priors();

  public:
  // float value = 2;
  void clear_value() ;
  float value() const;
  void set_value(float value);

  private:
  float _internal_value() const;
  void _internal_set_value(float value);

  public:
  // @@protoc_insertion_point(class_scope:hexzpb.TrainingExample.ModelPredictions)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr priors_;
    float value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hexz_2eproto;
};// -------------------------------------------------------------------

class TrainingExample_Stats final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hexzpb.TrainingExample.Stats) */ {
 public:
  inline TrainingExample_Stats() : TrainingExample_Stats(nullptr) {}
  ~TrainingExample_Stats() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TrainingExample_Stats(::google::protobuf::internal::ConstantInitialized);

  TrainingExample_Stats(const TrainingExample_Stats& from);
  TrainingExample_Stats(TrainingExample_Stats&& from) noexcept
    : TrainingExample_Stats() {
    *this = ::std::move(from);
  }

  inline TrainingExample_Stats& operator=(const TrainingExample_Stats& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrainingExample_Stats& operator=(TrainingExample_Stats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrainingExample_Stats& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrainingExample_Stats* internal_default_instance() {
    return reinterpret_cast<const TrainingExample_Stats*>(
               &_TrainingExample_Stats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(TrainingExample_Stats& a, TrainingExample_Stats& b) {
    a.Swap(&b);
  }
  inline void Swap(TrainingExample_Stats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrainingExample_Stats* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrainingExample_Stats* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrainingExample_Stats>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrainingExample_Stats& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TrainingExample_Stats& from) {
    TrainingExample_Stats::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrainingExample_Stats* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hexzpb.TrainingExample.Stats";
  }
  protected:
  explicit TrainingExample_Stats(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesPerDepthFieldNumber = 12,
    kDurationMicrosFieldNumber = 1,
    kValidMovesFieldNumber = 2,
    kVisitCountFieldNumber = 3,
    kVisitedChildrenFieldNumber = 4,
    kSearchDepthFieldNumber = 5,
    kSearchTreeSizeFieldNumber = 6,
    kBranchNodesFieldNumber = 7,
    kMinChildVcFieldNumber = 8,
    kMaxChildVcFieldNumber = 9,
    kSelectedChildVcFieldNumber = 10,
    kSelectedChildQFieldNumber = 13,
  };
  // repeated int32 nodes_per_depth = 12;
  int nodes_per_depth_size() const;
  private:
  int _internal_nodes_per_depth_size() const;

  public:
  void clear_nodes_per_depth() ;
  ::int32_t nodes_per_depth(int index) const;
  void set_nodes_per_depth(int index, ::int32_t value);
  void add_nodes_per_depth(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& nodes_per_depth() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_nodes_per_depth();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_nodes_per_depth() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_nodes_per_depth();

  public:
  // int64 duration_micros = 1;
  void clear_duration_micros() ;
  ::int64_t duration_micros() const;
  void set_duration_micros(::int64_t value);

  private:
  ::int64_t _internal_duration_micros() const;
  void _internal_set_duration_micros(::int64_t value);

  public:
  // int32 valid_moves = 2;
  void clear_valid_moves() ;
  ::int32_t valid_moves() const;
  void set_valid_moves(::int32_t value);

  private:
  ::int32_t _internal_valid_moves() const;
  void _internal_set_valid_moves(::int32_t value);

  public:
  // int32 visit_count = 3;
  void clear_visit_count() ;
  ::int32_t visit_count() const;
  void set_visit_count(::int32_t value);

  private:
  ::int32_t _internal_visit_count() const;
  void _internal_set_visit_count(::int32_t value);

  public:
  // int32 visited_children = 4;
  void clear_visited_children() ;
  ::int32_t visited_children() const;
  void set_visited_children(::int32_t value);

  private:
  ::int32_t _internal_visited_children() const;
  void _internal_set_visited_children(::int32_t value);

  public:
  // int32 search_depth = 5;
  void clear_search_depth() ;
  ::int32_t search_depth() const;
  void set_search_depth(::int32_t value);

  private:
  ::int32_t _internal_search_depth() const;
  void _internal_set_search_depth(::int32_t value);

  public:
  // int32 search_tree_size = 6;
  void clear_search_tree_size() ;
  ::int32_t search_tree_size() const;
  void set_search_tree_size(::int32_t value);

  private:
  ::int32_t _internal_search_tree_size() const;
  void _internal_set_search_tree_size(::int32_t value);

  public:
  // int32 branch_nodes = 7;
  void clear_branch_nodes() ;
  ::int32_t branch_nodes() const;
  void set_branch_nodes(::int32_t value);

  private:
  ::int32_t _internal_branch_nodes() const;
  void _internal_set_branch_nodes(::int32_t value);

  public:
  // int32 min_child_vc = 8;
  void clear_min_child_vc() ;
  ::int32_t min_child_vc() const;
  void set_min_child_vc(::int32_t value);

  private:
  ::int32_t _internal_min_child_vc() const;
  void _internal_set_min_child_vc(::int32_t value);

  public:
  // int32 max_child_vc = 9;
  void clear_max_child_vc() ;
  ::int32_t max_child_vc() const;
  void set_max_child_vc(::int32_t value);

  private:
  ::int32_t _internal_max_child_vc() const;
  void _internal_set_max_child_vc(::int32_t value);

  public:
  // int32 selected_child_vc = 10;
  void clear_selected_child_vc() ;
  ::int32_t selected_child_vc() const;
  void set_selected_child_vc(::int32_t value);

  private:
  ::int32_t _internal_selected_child_vc() const;
  void _internal_set_selected_child_vc(::int32_t value);

  public:
  // int32 selected_child_q = 13;
  void clear_selected_child_q() ;
  ::int32_t selected_child_q() const;
  void set_selected_child_q(::int32_t value);

  private:
  ::int32_t _internal_selected_child_q() const;
  void _internal_set_selected_child_q(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:hexzpb.TrainingExample.Stats)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 12, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedField<::int32_t> nodes_per_depth_;
    mutable ::google::protobuf::internal::CachedSize _nodes_per_depth_cached_byte_size_;
    ::int64_t duration_micros_;
    ::int32_t valid_moves_;
    ::int32_t visit_count_;
    ::int32_t visited_children_;
    ::int32_t search_depth_;
    ::int32_t search_tree_size_;
    ::int32_t branch_nodes_;
    ::int32_t min_child_vc_;
    ::int32_t max_child_vc_;
    ::int32_t selected_child_vc_;
    ::int32_t selected_child_q_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hexz_2eproto;
};// -------------------------------------------------------------------

class TrainingExample final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hexzpb.TrainingExample) */ {
 public:
  inline TrainingExample() : TrainingExample(nullptr) {}
  ~TrainingExample() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TrainingExample(::google::protobuf::internal::ConstantInitialized);

  TrainingExample(const TrainingExample& from);
  TrainingExample(TrainingExample&& from) noexcept
    : TrainingExample() {
    *this = ::std::move(from);
  }

  inline TrainingExample& operator=(const TrainingExample& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrainingExample& operator=(TrainingExample&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrainingExample& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrainingExample* internal_default_instance() {
    return reinterpret_cast<const TrainingExample*>(
               &_TrainingExample_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(TrainingExample& a, TrainingExample& b) {
    a.Swap(&b);
  }
  inline void Swap(TrainingExample* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrainingExample* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrainingExample* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrainingExample>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrainingExample& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TrainingExample& from) {
    TrainingExample::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrainingExample* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hexzpb.TrainingExample";
  }
  protected:
  explicit TrainingExample(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TrainingExample_ModelPredictions ModelPredictions;
  typedef TrainingExample_Stats Stats;

  using Encoding = TrainingExample_Encoding;
  static constexpr Encoding NUMPY = TrainingExample_Encoding_NUMPY;
  static constexpr Encoding PYTORCH = TrainingExample_Encoding_PYTORCH;
  static inline bool Encoding_IsValid(int value) {
    return TrainingExample_Encoding_IsValid(value);
  }
  static constexpr Encoding Encoding_MIN = TrainingExample_Encoding_Encoding_MIN;
  static constexpr Encoding Encoding_MAX = TrainingExample_Encoding_Encoding_MAX;
  static constexpr int Encoding_ARRAYSIZE = TrainingExample_Encoding_Encoding_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Encoding_descriptor() {
    return TrainingExample_Encoding_descriptor();
  }
  template <typename T>
  static inline const std::string& Encoding_Name(T value) {
    return TrainingExample_Encoding_Name(value);
  }
  static inline bool Encoding_Parse(absl::string_view name, Encoding* value) {
    return TrainingExample_Encoding_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBoardFieldNumber = 2,
    kMoveProbsFieldNumber = 3,
    kActionMaskFieldNumber = 8,
    kStatsFieldNumber = 5,
    kMoveFieldNumber = 9,
    kModelPredictionsFieldNumber = 10,
    kUnixMicrosFieldNumber = 1,
    kResultFieldNumber = 4,
    kEncodingFieldNumber = 6,
    kTurnFieldNumber = 7,
  };
  // bytes board = 2;
  void clear_board() ;
  const std::string& board() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_board(Arg_&& arg, Args_... args);
  std::string* mutable_board();
  PROTOBUF_NODISCARD std::string* release_board();
  void set_allocated_board(std::string* ptr);

  private:
  const std::string& _internal_board() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_board(
      const std::string& value);
  std::string* _internal_mutable_board();

  public:
  // bytes move_probs = 3;
  void clear_move_probs() ;
  const std::string& move_probs() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_move_probs(Arg_&& arg, Args_... args);
  std::string* mutable_move_probs();
  PROTOBUF_NODISCARD std::string* release_move_probs();
  void set_allocated_move_probs(std::string* ptr);

  private:
  const std::string& _internal_move_probs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_move_probs(
      const std::string& value);
  std::string* _internal_mutable_move_probs();

  public:
  // bytes action_mask = 8;
  void clear_action_mask() ;
  const std::string& action_mask() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_action_mask(Arg_&& arg, Args_... args);
  std::string* mutable_action_mask();
  PROTOBUF_NODISCARD std::string* release_action_mask();
  void set_allocated_action_mask(std::string* ptr);

  private:
  const std::string& _internal_action_mask() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action_mask(
      const std::string& value);
  std::string* _internal_mutable_action_mask();

  public:
  // .hexzpb.TrainingExample.Stats stats = 5;
  bool has_stats() const;
  void clear_stats() ;
  const ::hexzpb::TrainingExample_Stats& stats() const;
  PROTOBUF_NODISCARD ::hexzpb::TrainingExample_Stats* release_stats();
  ::hexzpb::TrainingExample_Stats* mutable_stats();
  void set_allocated_stats(::hexzpb::TrainingExample_Stats* value);
  void unsafe_arena_set_allocated_stats(::hexzpb::TrainingExample_Stats* value);
  ::hexzpb::TrainingExample_Stats* unsafe_arena_release_stats();

  private:
  const ::hexzpb::TrainingExample_Stats& _internal_stats() const;
  ::hexzpb::TrainingExample_Stats* _internal_mutable_stats();

  public:
  // .hexzpb.GameEngineMove move = 9;
  bool has_move() const;
  void clear_move() ;
  const ::hexzpb::GameEngineMove& move() const;
  PROTOBUF_NODISCARD ::hexzpb::GameEngineMove* release_move();
  ::hexzpb::GameEngineMove* mutable_move();
  void set_allocated_move(::hexzpb::GameEngineMove* value);
  void unsafe_arena_set_allocated_move(::hexzpb::GameEngineMove* value);
  ::hexzpb::GameEngineMove* unsafe_arena_release_move();

  private:
  const ::hexzpb::GameEngineMove& _internal_move() const;
  ::hexzpb::GameEngineMove* _internal_mutable_move();

  public:
  // .hexzpb.TrainingExample.ModelPredictions model_predictions = 10;
  bool has_model_predictions() const;
  void clear_model_predictions() ;
  const ::hexzpb::TrainingExample_ModelPredictions& model_predictions() const;
  PROTOBUF_NODISCARD ::hexzpb::TrainingExample_ModelPredictions* release_model_predictions();
  ::hexzpb::TrainingExample_ModelPredictions* mutable_model_predictions();
  void set_allocated_model_predictions(::hexzpb::TrainingExample_ModelPredictions* value);
  void unsafe_arena_set_allocated_model_predictions(::hexzpb::TrainingExample_ModelPredictions* value);
  ::hexzpb::TrainingExample_ModelPredictions* unsafe_arena_release_model_predictions();

  private:
  const ::hexzpb::TrainingExample_ModelPredictions& _internal_model_predictions() const;
  ::hexzpb::TrainingExample_ModelPredictions* _internal_mutable_model_predictions();

  public:
  // int64 unix_micros = 1;
  void clear_unix_micros() ;
  ::int64_t unix_micros() const;
  void set_unix_micros(::int64_t value);

  private:
  ::int64_t _internal_unix_micros() const;
  void _internal_set_unix_micros(::int64_t value);

  public:
  // float result = 4;
  void clear_result() ;
  float result() const;
  void set_result(float value);

  private:
  float _internal_result() const;
  void _internal_set_result(float value);

  public:
  // .hexzpb.TrainingExample.Encoding encoding = 6;
  void clear_encoding() ;
  ::hexzpb::TrainingExample_Encoding encoding() const;
  void set_encoding(::hexzpb::TrainingExample_Encoding value);

  private:
  ::hexzpb::TrainingExample_Encoding _internal_encoding() const;
  void _internal_set_encoding(::hexzpb::TrainingExample_Encoding value);

  public:
  // int32 turn = 7;
  void clear_turn() ;
  ::int32_t turn() const;
  void set_turn(::int32_t value);

  private:
  ::int32_t _internal_turn() const;
  void _internal_set_turn(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:hexzpb.TrainingExample)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 10, 3, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr board_;
    ::google::protobuf::internal::ArenaStringPtr move_probs_;
    ::google::protobuf::internal::ArenaStringPtr action_mask_;
    ::hexzpb::TrainingExample_Stats* stats_;
    ::hexzpb::GameEngineMove* move_;
    ::hexzpb::TrainingExample_ModelPredictions* model_predictions_;
    ::int64_t unix_micros_;
    float result_;
    int encoding_;
    ::int32_t turn_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hexz_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Board

// int32 turn = 1;
inline void Board::clear_turn() {
  _impl_.turn_ = 0;
}
inline ::int32_t Board::turn() const {
  // @@protoc_insertion_point(field_get:hexzpb.Board.turn)
  return _internal_turn();
}
inline void Board::set_turn(::int32_t value) {
  _internal_set_turn(value);
  // @@protoc_insertion_point(field_set:hexzpb.Board.turn)
}
inline ::int32_t Board::_internal_turn() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.turn_;
}
inline void Board::_internal_set_turn(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.turn_ = value;
}

// int32 move = 2;
inline void Board::clear_move() {
  _impl_.move_ = 0;
}
inline ::int32_t Board::move() const {
  // @@protoc_insertion_point(field_get:hexzpb.Board.move)
  return _internal_move();
}
inline void Board::set_move(::int32_t value) {
  _internal_set_move(value);
  // @@protoc_insertion_point(field_set:hexzpb.Board.move)
}
inline ::int32_t Board::_internal_move() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.move_;
}
inline void Board::_internal_set_move(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.move_ = value;
}

// int32 last_revealed = 3;
inline void Board::clear_last_revealed() {
  _impl_.last_revealed_ = 0;
}
inline ::int32_t Board::last_revealed() const {
  // @@protoc_insertion_point(field_get:hexzpb.Board.last_revealed)
  return _internal_last_revealed();
}
inline void Board::set_last_revealed(::int32_t value) {
  _internal_set_last_revealed(value);
  // @@protoc_insertion_point(field_set:hexzpb.Board.last_revealed)
}
inline ::int32_t Board::_internal_last_revealed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.last_revealed_;
}
inline void Board::_internal_set_last_revealed(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.last_revealed_ = value;
}

// repeated .hexzpb.Field flat_fields = 4;
inline int Board::_internal_flat_fields_size() const {
  return _internal_flat_fields().size();
}
inline int Board::flat_fields_size() const {
  return _internal_flat_fields_size();
}
inline void Board::clear_flat_fields() {
  _internal_mutable_flat_fields()->Clear();
}
inline ::hexzpb::Field* Board::mutable_flat_fields(int index) {
  // @@protoc_insertion_point(field_mutable:hexzpb.Board.flat_fields)
  return _internal_mutable_flat_fields()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hexzpb::Field >*
Board::mutable_flat_fields() {
  // @@protoc_insertion_point(field_mutable_list:hexzpb.Board.flat_fields)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_flat_fields();
}
inline const ::hexzpb::Field& Board::flat_fields(int index) const {
  // @@protoc_insertion_point(field_get:hexzpb.Board.flat_fields)
    return _internal_flat_fields().Get(index);
}
inline ::hexzpb::Field* Board::add_flat_fields() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::hexzpb::Field* _add = _internal_mutable_flat_fields()->Add();
  // @@protoc_insertion_point(field_add:hexzpb.Board.flat_fields)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::hexzpb::Field >&
Board::flat_fields() const {
  // @@protoc_insertion_point(field_list:hexzpb.Board.flat_fields)
  return _internal_flat_fields();
}
inline const ::google::protobuf::RepeatedPtrField<::hexzpb::Field>&
Board::_internal_flat_fields() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.flat_fields_;
}
inline ::google::protobuf::RepeatedPtrField<::hexzpb::Field>*
Board::_internal_mutable_flat_fields() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.flat_fields_;
}

// repeated int32 score = 5;
inline int Board::_internal_score_size() const {
  return _internal_score().size();
}
inline int Board::score_size() const {
  return _internal_score_size();
}
inline void Board::clear_score() {
  _internal_mutable_score()->Clear();
}
inline ::int32_t Board::score(int index) const {
  // @@protoc_insertion_point(field_get:hexzpb.Board.score)
  return _internal_score().Get(index);
}
inline void Board::set_score(int index, ::int32_t value) {
  _internal_mutable_score()->Set(index, value);
  // @@protoc_insertion_point(field_set:hexzpb.Board.score)
}
inline void Board::add_score(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_score()->Add(value);
  // @@protoc_insertion_point(field_add:hexzpb.Board.score)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& Board::score() const {
  // @@protoc_insertion_point(field_list:hexzpb.Board.score)
  return _internal_score();
}
inline ::google::protobuf::RepeatedField<::int32_t>* Board::mutable_score() {
  // @@protoc_insertion_point(field_mutable_list:hexzpb.Board.score)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_score();
}

inline const ::google::protobuf::RepeatedField<::int32_t>& Board::_internal_score() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.score_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* Board::_internal_mutable_score() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.score_;
}

// repeated .hexzpb.ResourceInfo resources = 6;
inline int Board::_internal_resources_size() const {
  return _internal_resources().size();
}
inline int Board::resources_size() const {
  return _internal_resources_size();
}
inline void Board::clear_resources() {
  _internal_mutable_resources()->Clear();
}
inline ::hexzpb::ResourceInfo* Board::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:hexzpb.Board.resources)
  return _internal_mutable_resources()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hexzpb::ResourceInfo >*
Board::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:hexzpb.Board.resources)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_resources();
}
inline const ::hexzpb::ResourceInfo& Board::resources(int index) const {
  // @@protoc_insertion_point(field_get:hexzpb.Board.resources)
    return _internal_resources().Get(index);
}
inline ::hexzpb::ResourceInfo* Board::add_resources() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::hexzpb::ResourceInfo* _add = _internal_mutable_resources()->Add();
  // @@protoc_insertion_point(field_add:hexzpb.Board.resources)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::hexzpb::ResourceInfo >&
Board::resources() const {
  // @@protoc_insertion_point(field_list:hexzpb.Board.resources)
  return _internal_resources();
}
inline const ::google::protobuf::RepeatedPtrField<::hexzpb::ResourceInfo>&
Board::_internal_resources() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.resources_;
}
inline ::google::protobuf::RepeatedPtrField<::hexzpb::ResourceInfo>*
Board::_internal_mutable_resources() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.resources_;
}

// .hexzpb.Board.GameState state = 7;
inline void Board::clear_state() {
  _impl_.state_ = 0;
}
inline ::hexzpb::Board_GameState Board::state() const {
  // @@protoc_insertion_point(field_get:hexzpb.Board.state)
  return _internal_state();
}
inline void Board::set_state(::hexzpb::Board_GameState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:hexzpb.Board.state)
}
inline ::hexzpb::Board_GameState Board::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::hexzpb::Board_GameState>(_impl_.state_);
}
inline void Board::_internal_set_state(::hexzpb::Board_GameState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.state_ = value;
}

// -------------------------------------------------------------------

// Field

// .hexzpb.Field.CellType type = 1;
inline void Field::clear_type() {
  _impl_.type_ = 0;
}
inline ::hexzpb::Field_CellType Field::type() const {
  // @@protoc_insertion_point(field_get:hexzpb.Field.type)
  return _internal_type();
}
inline void Field::set_type(::hexzpb::Field_CellType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:hexzpb.Field.type)
}
inline ::hexzpb::Field_CellType Field::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::hexzpb::Field_CellType>(_impl_.type_);
}
inline void Field::_internal_set_type(::hexzpb::Field_CellType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// int32 owner = 2;
inline void Field::clear_owner() {
  _impl_.owner_ = 0;
}
inline ::int32_t Field::owner() const {
  // @@protoc_insertion_point(field_get:hexzpb.Field.owner)
  return _internal_owner();
}
inline void Field::set_owner(::int32_t value) {
  _internal_set_owner(value);
  // @@protoc_insertion_point(field_set:hexzpb.Field.owner)
}
inline ::int32_t Field::_internal_owner() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.owner_;
}
inline void Field::_internal_set_owner(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.owner_ = value;
}

// bool hidden = 3;
inline void Field::clear_hidden() {
  _impl_.hidden_ = false;
}
inline bool Field::hidden() const {
  // @@protoc_insertion_point(field_get:hexzpb.Field.hidden)
  return _internal_hidden();
}
inline void Field::set_hidden(bool value) {
  _internal_set_hidden(value);
  // @@protoc_insertion_point(field_set:hexzpb.Field.hidden)
}
inline bool Field::_internal_hidden() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hidden_;
}
inline void Field::_internal_set_hidden(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hidden_ = value;
}

// int32 value = 4;
inline void Field::clear_value() {
  _impl_.value_ = 0;
}
inline ::int32_t Field::value() const {
  // @@protoc_insertion_point(field_get:hexzpb.Field.value)
  return _internal_value();
}
inline void Field::set_value(::int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:hexzpb.Field.value)
}
inline ::int32_t Field::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void Field::_internal_set_value(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// int32 blocked = 5;
inline void Field::clear_blocked() {
  _impl_.blocked_ = 0;
}
inline ::int32_t Field::blocked() const {
  // @@protoc_insertion_point(field_get:hexzpb.Field.blocked)
  return _internal_blocked();
}
inline void Field::set_blocked(::int32_t value) {
  _internal_set_blocked(value);
  // @@protoc_insertion_point(field_set:hexzpb.Field.blocked)
}
inline ::int32_t Field::_internal_blocked() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.blocked_;
}
inline void Field::_internal_set_blocked(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.blocked_ = value;
}

// int32 lifetime = 6;
inline void Field::clear_lifetime() {
  _impl_.lifetime_ = 0;
}
inline ::int32_t Field::lifetime() const {
  // @@protoc_insertion_point(field_get:hexzpb.Field.lifetime)
  return _internal_lifetime();
}
inline void Field::set_lifetime(::int32_t value) {
  _internal_set_lifetime(value);
  // @@protoc_insertion_point(field_set:hexzpb.Field.lifetime)
}
inline ::int32_t Field::_internal_lifetime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lifetime_;
}
inline void Field::_internal_set_lifetime(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.lifetime_ = value;
}

// repeated int32 next_val = 7;
inline int Field::_internal_next_val_size() const {
  return _internal_next_val().size();
}
inline int Field::next_val_size() const {
  return _internal_next_val_size();
}
inline void Field::clear_next_val() {
  _internal_mutable_next_val()->Clear();
}
inline ::int32_t Field::next_val(int index) const {
  // @@protoc_insertion_point(field_get:hexzpb.Field.next_val)
  return _internal_next_val().Get(index);
}
inline void Field::set_next_val(int index, ::int32_t value) {
  _internal_mutable_next_val()->Set(index, value);
  // @@protoc_insertion_point(field_set:hexzpb.Field.next_val)
}
inline void Field::add_next_val(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_next_val()->Add(value);
  // @@protoc_insertion_point(field_add:hexzpb.Field.next_val)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& Field::next_val() const {
  // @@protoc_insertion_point(field_list:hexzpb.Field.next_val)
  return _internal_next_val();
}
inline ::google::protobuf::RepeatedField<::int32_t>* Field::mutable_next_val() {
  // @@protoc_insertion_point(field_mutable_list:hexzpb.Field.next_val)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_next_val();
}

inline const ::google::protobuf::RepeatedField<::int32_t>& Field::_internal_next_val() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.next_val_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* Field::_internal_mutable_next_val() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.next_val_;
}

// -------------------------------------------------------------------

// ResourceInfo

// repeated int32 num_pieces = 1;
inline int ResourceInfo::_internal_num_pieces_size() const {
  return _internal_num_pieces().size();
}
inline int ResourceInfo::num_pieces_size() const {
  return _internal_num_pieces_size();
}
inline void ResourceInfo::clear_num_pieces() {
  _internal_mutable_num_pieces()->Clear();
}
inline ::int32_t ResourceInfo::num_pieces(int index) const {
  // @@protoc_insertion_point(field_get:hexzpb.ResourceInfo.num_pieces)
  return _internal_num_pieces().Get(index);
}
inline void ResourceInfo::set_num_pieces(int index, ::int32_t value) {
  _internal_mutable_num_pieces()->Set(index, value);
  // @@protoc_insertion_point(field_set:hexzpb.ResourceInfo.num_pieces)
}
inline void ResourceInfo::add_num_pieces(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_num_pieces()->Add(value);
  // @@protoc_insertion_point(field_add:hexzpb.ResourceInfo.num_pieces)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& ResourceInfo::num_pieces() const {
  // @@protoc_insertion_point(field_list:hexzpb.ResourceInfo.num_pieces)
  return _internal_num_pieces();
}
inline ::google::protobuf::RepeatedField<::int32_t>* ResourceInfo::mutable_num_pieces() {
  // @@protoc_insertion_point(field_mutable_list:hexzpb.ResourceInfo.num_pieces)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_num_pieces();
}

inline const ::google::protobuf::RepeatedField<::int32_t>& ResourceInfo::_internal_num_pieces() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_pieces_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* ResourceInfo::_internal_mutable_num_pieces() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.num_pieces_;
}

// -------------------------------------------------------------------

// Player

// string id = 1;
inline void Player::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Player::id() const {
  // @@protoc_insertion_point(field_get:hexzpb.Player.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Player::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hexzpb.Player.id)
}
inline std::string* Player::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:hexzpb.Player.id)
  return _s;
}
inline const std::string& Player::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void Player::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Player::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* Player::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hexzpb.Player.id)
  return _impl_.id_.Release();
}
inline void Player::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hexzpb.Player.id)
}

// string name = 2;
inline void Player::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Player::name() const {
  // @@protoc_insertion_point(field_get:hexzpb.Player.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Player::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hexzpb.Player.name)
}
inline std::string* Player::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:hexzpb.Player.name)
  return _s;
}
inline const std::string& Player::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Player::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Player::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* Player::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hexzpb.Player.name)
  return _impl_.name_.Release();
}
inline void Player::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hexzpb.Player.name)
}

// -------------------------------------------------------------------

// GameInfo

// string id = 1;
inline void GameInfo::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GameInfo::id() const {
  // @@protoc_insertion_point(field_get:hexzpb.GameInfo.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GameInfo::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hexzpb.GameInfo.id)
}
inline std::string* GameInfo::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:hexzpb.GameInfo.id)
  return _s;
}
inline const std::string& GameInfo::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void GameInfo::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* GameInfo::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* GameInfo::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hexzpb.GameInfo.id)
  return _impl_.id_.Release();
}
inline void GameInfo::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hexzpb.GameInfo.id)
}

// string host = 2;
inline void GameInfo::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& GameInfo::host() const {
  // @@protoc_insertion_point(field_get:hexzpb.GameInfo.host)
  return _internal_host();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GameInfo::set_host(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.host_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hexzpb.GameInfo.host)
}
inline std::string* GameInfo::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:hexzpb.GameInfo.host)
  return _s;
}
inline const std::string& GameInfo::_internal_host() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.host_.Get();
}
inline void GameInfo::_internal_set_host(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* GameInfo::_internal_mutable_host() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.host_.Mutable( GetArenaForAllocation());
}
inline std::string* GameInfo::release_host() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hexzpb.GameInfo.host)
  return _impl_.host_.Release();
}
inline void GameInfo::set_allocated_host(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.host_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.host_.IsDefault()) {
          _impl_.host_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hexzpb.GameInfo.host)
}

// .google.protobuf.Timestamp started = 3;
inline bool GameInfo::has_started() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.started_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& GameInfo::_internal_started() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.started_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& GameInfo::started() const {
  // @@protoc_insertion_point(field_get:hexzpb.GameInfo.started)
  return _internal_started();
}
inline void GameInfo::unsafe_arena_set_allocated_started(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.started_);
  }
  _impl_.started_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hexzpb.GameInfo.started)
}
inline ::google::protobuf::Timestamp* GameInfo::release_started() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.started_;
  _impl_.started_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* GameInfo::unsafe_arena_release_started() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hexzpb.GameInfo.started)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.started_;
  _impl_.started_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* GameInfo::_internal_mutable_started() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.started_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaForAllocation());
    _impl_.started_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.started_;
}
inline ::google::protobuf::Timestamp* GameInfo::mutable_started() {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_started();
  // @@protoc_insertion_point(field_mutable:hexzpb.GameInfo.started)
  return _msg;
}
inline void GameInfo::set_allocated_started(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.started_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.started_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:hexzpb.GameInfo.started)
}

// string type = 4;
inline void GameInfo::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& GameInfo::type() const {
  // @@protoc_insertion_point(field_get:hexzpb.GameInfo.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GameInfo::set_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hexzpb.GameInfo.type)
}
inline std::string* GameInfo::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:hexzpb.GameInfo.type)
  return _s;
}
inline const std::string& GameInfo::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_.Get();
}
inline void GameInfo::_internal_set_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* GameInfo::_internal_mutable_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.type_.Mutable( GetArenaForAllocation());
}
inline std::string* GameInfo::release_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hexzpb.GameInfo.type)
  return _impl_.type_.Release();
}
inline void GameInfo::set_allocated_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hexzpb.GameInfo.type)
}

// bool cpu_player = 5;
inline void GameInfo::clear_cpu_player() {
  _impl_.cpu_player_ = false;
}
inline bool GameInfo::cpu_player() const {
  // @@protoc_insertion_point(field_get:hexzpb.GameInfo.cpu_player)
  return _internal_cpu_player();
}
inline void GameInfo::set_cpu_player(bool value) {
  _internal_set_cpu_player(value);
  // @@protoc_insertion_point(field_set:hexzpb.GameInfo.cpu_player)
}
inline bool GameInfo::_internal_cpu_player() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cpu_player_;
}
inline void GameInfo::_internal_set_cpu_player(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cpu_player_ = value;
}

// -------------------------------------------------------------------

// GameState

// .hexzpb.GameInfo game_info = 1;
inline bool GameState::has_game_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.game_info_ != nullptr);
  return value;
}
inline void GameState::clear_game_info() {
  if (_impl_.game_info_ != nullptr) _impl_.game_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::hexzpb::GameInfo& GameState::_internal_game_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::hexzpb::GameInfo* p = _impl_.game_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::hexzpb::GameInfo&>(::hexzpb::_GameInfo_default_instance_);
}
inline const ::hexzpb::GameInfo& GameState::game_info() const {
  // @@protoc_insertion_point(field_get:hexzpb.GameState.game_info)
  return _internal_game_info();
}
inline void GameState::unsafe_arena_set_allocated_game_info(::hexzpb::GameInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.game_info_);
  }
  _impl_.game_info_ = reinterpret_cast<::hexzpb::GameInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hexzpb.GameState.game_info)
}
inline ::hexzpb::GameInfo* GameState::release_game_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hexzpb::GameInfo* released = _impl_.game_info_;
  _impl_.game_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::hexzpb::GameInfo* GameState::unsafe_arena_release_game_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hexzpb.GameState.game_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hexzpb::GameInfo* temp = _impl_.game_info_;
  _impl_.game_info_ = nullptr;
  return temp;
}
inline ::hexzpb::GameInfo* GameState::_internal_mutable_game_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.game_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::hexzpb::GameInfo>(GetArenaForAllocation());
    _impl_.game_info_ = reinterpret_cast<::hexzpb::GameInfo*>(p);
  }
  return _impl_.game_info_;
}
inline ::hexzpb::GameInfo* GameState::mutable_game_info() {
  ::hexzpb::GameInfo* _msg = _internal_mutable_game_info();
  // @@protoc_insertion_point(field_mutable:hexzpb.GameState.game_info)
  return _msg;
}
inline void GameState::set_allocated_game_info(::hexzpb::GameInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::hexzpb::GameInfo*>(_impl_.game_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::hexzpb::GameInfo*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.game_info_ = reinterpret_cast<::hexzpb::GameInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:hexzpb.GameState.game_info)
}

// int64 seqnum = 2;
inline void GameState::clear_seqnum() {
  _impl_.seqnum_ = ::int64_t{0};
}
inline ::int64_t GameState::seqnum() const {
  // @@protoc_insertion_point(field_get:hexzpb.GameState.seqnum)
  return _internal_seqnum();
}
inline void GameState::set_seqnum(::int64_t value) {
  _internal_set_seqnum(value);
  // @@protoc_insertion_point(field_set:hexzpb.GameState.seqnum)
}
inline ::int64_t GameState::_internal_seqnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.seqnum_;
}
inline void GameState::_internal_set_seqnum(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.seqnum_ = value;
}

// .google.protobuf.Timestamp modified = 4;
inline bool GameState::has_modified() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.modified_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& GameState::_internal_modified() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.modified_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& GameState::modified() const {
  // @@protoc_insertion_point(field_get:hexzpb.GameState.modified)
  return _internal_modified();
}
inline void GameState::unsafe_arena_set_allocated_modified(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.modified_);
  }
  _impl_.modified_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hexzpb.GameState.modified)
}
inline ::google::protobuf::Timestamp* GameState::release_modified() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.modified_;
  _impl_.modified_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* GameState::unsafe_arena_release_modified() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hexzpb.GameState.modified)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.modified_;
  _impl_.modified_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* GameState::_internal_mutable_modified() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.modified_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaForAllocation());
    _impl_.modified_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.modified_;
}
inline ::google::protobuf::Timestamp* GameState::mutable_modified() {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_modified();
  // @@protoc_insertion_point(field_mutable:hexzpb.GameState.modified)
  return _msg;
}
inline void GameState::set_allocated_modified(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.modified_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.modified_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:hexzpb.GameState.modified)
}

// repeated .hexzpb.Player players = 5;
inline int GameState::_internal_players_size() const {
  return _internal_players().size();
}
inline int GameState::players_size() const {
  return _internal_players_size();
}
inline void GameState::clear_players() {
  _internal_mutable_players()->Clear();
}
inline ::hexzpb::Player* GameState::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:hexzpb.GameState.players)
  return _internal_mutable_players()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hexzpb::Player >*
GameState::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:hexzpb.GameState.players)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_players();
}
inline const ::hexzpb::Player& GameState::players(int index) const {
  // @@protoc_insertion_point(field_get:hexzpb.GameState.players)
    return _internal_players().Get(index);
}
inline ::hexzpb::Player* GameState::add_players() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::hexzpb::Player* _add = _internal_mutable_players()->Add();
  // @@protoc_insertion_point(field_add:hexzpb.GameState.players)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::hexzpb::Player >&
GameState::players() const {
  // @@protoc_insertion_point(field_list:hexzpb.GameState.players)
  return _internal_players();
}
inline const ::google::protobuf::RepeatedPtrField<::hexzpb::Player>&
GameState::_internal_players() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.players_;
}
inline ::google::protobuf::RepeatedPtrField<::hexzpb::Player>*
GameState::_internal_mutable_players() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.players_;
}

// .hexzpb.GameEngineState engine_state = 6;
inline bool GameState::has_engine_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.engine_state_ != nullptr);
  return value;
}
inline void GameState::clear_engine_state() {
  if (_impl_.engine_state_ != nullptr) _impl_.engine_state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::hexzpb::GameEngineState& GameState::_internal_engine_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::hexzpb::GameEngineState* p = _impl_.engine_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::hexzpb::GameEngineState&>(::hexzpb::_GameEngineState_default_instance_);
}
inline const ::hexzpb::GameEngineState& GameState::engine_state() const {
  // @@protoc_insertion_point(field_get:hexzpb.GameState.engine_state)
  return _internal_engine_state();
}
inline void GameState::unsafe_arena_set_allocated_engine_state(::hexzpb::GameEngineState* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.engine_state_);
  }
  _impl_.engine_state_ = reinterpret_cast<::hexzpb::GameEngineState*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hexzpb.GameState.engine_state)
}
inline ::hexzpb::GameEngineState* GameState::release_engine_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::hexzpb::GameEngineState* released = _impl_.engine_state_;
  _impl_.engine_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::hexzpb::GameEngineState* GameState::unsafe_arena_release_engine_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hexzpb.GameState.engine_state)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::hexzpb::GameEngineState* temp = _impl_.engine_state_;
  _impl_.engine_state_ = nullptr;
  return temp;
}
inline ::hexzpb::GameEngineState* GameState::_internal_mutable_engine_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.engine_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::hexzpb::GameEngineState>(GetArenaForAllocation());
    _impl_.engine_state_ = reinterpret_cast<::hexzpb::GameEngineState*>(p);
  }
  return _impl_.engine_state_;
}
inline ::hexzpb::GameEngineState* GameState::mutable_engine_state() {
  ::hexzpb::GameEngineState* _msg = _internal_mutable_engine_state();
  // @@protoc_insertion_point(field_mutable:hexzpb.GameState.engine_state)
  return _msg;
}
inline void GameState::set_allocated_engine_state(::hexzpb::GameEngineState* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::hexzpb::GameEngineState*>(_impl_.engine_state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::hexzpb::GameEngineState*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.engine_state_ = reinterpret_cast<::hexzpb::GameEngineState*>(value);
  // @@protoc_insertion_point(field_set_allocated:hexzpb.GameState.engine_state)
}

// -------------------------------------------------------------------

// GameEngineState

// .hexzpb.GameEngineFlagzState flagz = 1;
inline bool GameEngineState::has_flagz() const {
  return state_case() == kFlagz;
}
inline bool GameEngineState::_internal_has_flagz() const {
  return state_case() == kFlagz;
}
inline void GameEngineState::set_has_flagz() {
  _impl_._oneof_case_[0] = kFlagz;
}
inline void GameEngineState::clear_flagz() {
  if (state_case() == kFlagz) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.state_.flagz_;
    }
    clear_has_state();
  }
}
inline ::hexzpb::GameEngineFlagzState* GameEngineState::release_flagz() {
  // @@protoc_insertion_point(field_release:hexzpb.GameEngineState.flagz)
  if (state_case() == kFlagz) {
    clear_has_state();
    ::hexzpb::GameEngineFlagzState* temp = _impl_.state_.flagz_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.state_.flagz_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::hexzpb::GameEngineFlagzState& GameEngineState::_internal_flagz() const {
  return state_case() == kFlagz
      ? *_impl_.state_.flagz_
      : reinterpret_cast<::hexzpb::GameEngineFlagzState&>(::hexzpb::_GameEngineFlagzState_default_instance_);
}
inline const ::hexzpb::GameEngineFlagzState& GameEngineState::flagz() const {
  // @@protoc_insertion_point(field_get:hexzpb.GameEngineState.flagz)
  return _internal_flagz();
}
inline ::hexzpb::GameEngineFlagzState* GameEngineState::unsafe_arena_release_flagz() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hexzpb.GameEngineState.flagz)
  if (state_case() == kFlagz) {
    clear_has_state();
    ::hexzpb::GameEngineFlagzState* temp = _impl_.state_.flagz_;
    _impl_.state_.flagz_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameEngineState::unsafe_arena_set_allocated_flagz(::hexzpb::GameEngineFlagzState* flagz) {
  clear_state();
  if (flagz) {
    set_has_flagz();
    _impl_.state_.flagz_ = flagz;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hexzpb.GameEngineState.flagz)
}
inline ::hexzpb::GameEngineFlagzState* GameEngineState::_internal_mutable_flagz() {
  if (state_case() != kFlagz) {
    clear_state();
    set_has_flagz();
    _impl_.state_.flagz_ = CreateMaybeMessage< ::hexzpb::GameEngineFlagzState >(GetArenaForAllocation());
  }
  return _impl_.state_.flagz_;
}
inline ::hexzpb::GameEngineFlagzState* GameEngineState::mutable_flagz() {
  ::hexzpb::GameEngineFlagzState* _msg = _internal_mutable_flagz();
  // @@protoc_insertion_point(field_mutable:hexzpb.GameEngineState.flagz)
  return _msg;
}

// .hexzpb.GameEngineClassicState classic = 2;
inline bool GameEngineState::has_classic() const {
  return state_case() == kClassic;
}
inline bool GameEngineState::_internal_has_classic() const {
  return state_case() == kClassic;
}
inline void GameEngineState::set_has_classic() {
  _impl_._oneof_case_[0] = kClassic;
}
inline void GameEngineState::clear_classic() {
  if (state_case() == kClassic) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.state_.classic_;
    }
    clear_has_state();
  }
}
inline ::hexzpb::GameEngineClassicState* GameEngineState::release_classic() {
  // @@protoc_insertion_point(field_release:hexzpb.GameEngineState.classic)
  if (state_case() == kClassic) {
    clear_has_state();
    ::hexzpb::GameEngineClassicState* temp = _impl_.state_.classic_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.state_.classic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::hexzpb::GameEngineClassicState& GameEngineState::_internal_classic() const {
  return state_case() == kClassic
      ? *_impl_.state_.classic_
      : reinterpret_cast<::hexzpb::GameEngineClassicState&>(::hexzpb::_GameEngineClassicState_default_instance_);
}
inline const ::hexzpb::GameEngineClassicState& GameEngineState::classic() const {
  // @@protoc_insertion_point(field_get:hexzpb.GameEngineState.classic)
  return _internal_classic();
}
inline ::hexzpb::GameEngineClassicState* GameEngineState::unsafe_arena_release_classic() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hexzpb.GameEngineState.classic)
  if (state_case() == kClassic) {
    clear_has_state();
    ::hexzpb::GameEngineClassicState* temp = _impl_.state_.classic_;
    _impl_.state_.classic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameEngineState::unsafe_arena_set_allocated_classic(::hexzpb::GameEngineClassicState* classic) {
  clear_state();
  if (classic) {
    set_has_classic();
    _impl_.state_.classic_ = classic;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hexzpb.GameEngineState.classic)
}
inline ::hexzpb::GameEngineClassicState* GameEngineState::_internal_mutable_classic() {
  if (state_case() != kClassic) {
    clear_state();
    set_has_classic();
    _impl_.state_.classic_ = CreateMaybeMessage< ::hexzpb::GameEngineClassicState >(GetArenaForAllocation());
  }
  return _impl_.state_.classic_;
}
inline ::hexzpb::GameEngineClassicState* GameEngineState::mutable_classic() {
  ::hexzpb::GameEngineClassicState* _msg = _internal_mutable_classic();
  // @@protoc_insertion_point(field_mutable:hexzpb.GameEngineState.classic)
  return _msg;
}

// .hexzpb.GameEngineFreeformState freeform = 3;
inline bool GameEngineState::has_freeform() const {
  return state_case() == kFreeform;
}
inline bool GameEngineState::_internal_has_freeform() const {
  return state_case() == kFreeform;
}
inline void GameEngineState::set_has_freeform() {
  _impl_._oneof_case_[0] = kFreeform;
}
inline void GameEngineState::clear_freeform() {
  if (state_case() == kFreeform) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.state_.freeform_;
    }
    clear_has_state();
  }
}
inline ::hexzpb::GameEngineFreeformState* GameEngineState::release_freeform() {
  // @@protoc_insertion_point(field_release:hexzpb.GameEngineState.freeform)
  if (state_case() == kFreeform) {
    clear_has_state();
    ::hexzpb::GameEngineFreeformState* temp = _impl_.state_.freeform_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.state_.freeform_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::hexzpb::GameEngineFreeformState& GameEngineState::_internal_freeform() const {
  return state_case() == kFreeform
      ? *_impl_.state_.freeform_
      : reinterpret_cast<::hexzpb::GameEngineFreeformState&>(::hexzpb::_GameEngineFreeformState_default_instance_);
}
inline const ::hexzpb::GameEngineFreeformState& GameEngineState::freeform() const {
  // @@protoc_insertion_point(field_get:hexzpb.GameEngineState.freeform)
  return _internal_freeform();
}
inline ::hexzpb::GameEngineFreeformState* GameEngineState::unsafe_arena_release_freeform() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hexzpb.GameEngineState.freeform)
  if (state_case() == kFreeform) {
    clear_has_state();
    ::hexzpb::GameEngineFreeformState* temp = _impl_.state_.freeform_;
    _impl_.state_.freeform_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameEngineState::unsafe_arena_set_allocated_freeform(::hexzpb::GameEngineFreeformState* freeform) {
  clear_state();
  if (freeform) {
    set_has_freeform();
    _impl_.state_.freeform_ = freeform;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hexzpb.GameEngineState.freeform)
}
inline ::hexzpb::GameEngineFreeformState* GameEngineState::_internal_mutable_freeform() {
  if (state_case() != kFreeform) {
    clear_state();
    set_has_freeform();
    _impl_.state_.freeform_ = CreateMaybeMessage< ::hexzpb::GameEngineFreeformState >(GetArenaForAllocation());
  }
  return _impl_.state_.freeform_;
}
inline ::hexzpb::GameEngineFreeformState* GameEngineState::mutable_freeform() {
  ::hexzpb::GameEngineFreeformState* _msg = _internal_mutable_freeform();
  // @@protoc_insertion_point(field_mutable:hexzpb.GameEngineState.freeform)
  return _msg;
}

inline bool GameEngineState::has_state() const {
  return state_case() != STATE_NOT_SET;
}
inline void GameEngineState::clear_has_state() {
  _impl_._oneof_case_[0] = STATE_NOT_SET;
}
inline GameEngineState::StateCase GameEngineState::state_case() const {
  return GameEngineState::StateCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GameEngineFlagzState

// .hexzpb.Board board = 1;
inline bool GameEngineFlagzState::has_board() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.board_ != nullptr);
  return value;
}
inline void GameEngineFlagzState::clear_board() {
  if (_impl_.board_ != nullptr) _impl_.board_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::hexzpb::Board& GameEngineFlagzState::_internal_board() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::hexzpb::Board* p = _impl_.board_;
  return p != nullptr ? *p : reinterpret_cast<const ::hexzpb::Board&>(::hexzpb::_Board_default_instance_);
}
inline const ::hexzpb::Board& GameEngineFlagzState::board() const {
  // @@protoc_insertion_point(field_get:hexzpb.GameEngineFlagzState.board)
  return _internal_board();
}
inline void GameEngineFlagzState::unsafe_arena_set_allocated_board(::hexzpb::Board* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.board_);
  }
  _impl_.board_ = reinterpret_cast<::hexzpb::Board*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hexzpb.GameEngineFlagzState.board)
}
inline ::hexzpb::Board* GameEngineFlagzState::release_board() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hexzpb::Board* released = _impl_.board_;
  _impl_.board_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::hexzpb::Board* GameEngineFlagzState::unsafe_arena_release_board() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hexzpb.GameEngineFlagzState.board)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hexzpb::Board* temp = _impl_.board_;
  _impl_.board_ = nullptr;
  return temp;
}
inline ::hexzpb::Board* GameEngineFlagzState::_internal_mutable_board() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.board_ == nullptr) {
    auto* p = CreateMaybeMessage<::hexzpb::Board>(GetArenaForAllocation());
    _impl_.board_ = reinterpret_cast<::hexzpb::Board*>(p);
  }
  return _impl_.board_;
}
inline ::hexzpb::Board* GameEngineFlagzState::mutable_board() {
  ::hexzpb::Board* _msg = _internal_mutable_board();
  // @@protoc_insertion_point(field_mutable:hexzpb.GameEngineFlagzState.board)
  return _msg;
}
inline void GameEngineFlagzState::set_allocated_board(::hexzpb::Board* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::hexzpb::Board*>(_impl_.board_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::hexzpb::Board*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.board_ = reinterpret_cast<::hexzpb::Board*>(value);
  // @@protoc_insertion_point(field_set_allocated:hexzpb.GameEngineFlagzState.board)
}

// int32 free_cells = 2;
inline void GameEngineFlagzState::clear_free_cells() {
  _impl_.free_cells_ = 0;
}
inline ::int32_t GameEngineFlagzState::free_cells() const {
  // @@protoc_insertion_point(field_get:hexzpb.GameEngineFlagzState.free_cells)
  return _internal_free_cells();
}
inline void GameEngineFlagzState::set_free_cells(::int32_t value) {
  _internal_set_free_cells(value);
  // @@protoc_insertion_point(field_set:hexzpb.GameEngineFlagzState.free_cells)
}
inline ::int32_t GameEngineFlagzState::_internal_free_cells() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.free_cells_;
}
inline void GameEngineFlagzState::_internal_set_free_cells(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.free_cells_ = value;
}

// repeated int32 normal_moves = 3;
inline int GameEngineFlagzState::_internal_normal_moves_size() const {
  return _internal_normal_moves().size();
}
inline int GameEngineFlagzState::normal_moves_size() const {
  return _internal_normal_moves_size();
}
inline void GameEngineFlagzState::clear_normal_moves() {
  _internal_mutable_normal_moves()->Clear();
}
inline ::int32_t GameEngineFlagzState::normal_moves(int index) const {
  // @@protoc_insertion_point(field_get:hexzpb.GameEngineFlagzState.normal_moves)
  return _internal_normal_moves().Get(index);
}
inline void GameEngineFlagzState::set_normal_moves(int index, ::int32_t value) {
  _internal_mutable_normal_moves()->Set(index, value);
  // @@protoc_insertion_point(field_set:hexzpb.GameEngineFlagzState.normal_moves)
}
inline void GameEngineFlagzState::add_normal_moves(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_normal_moves()->Add(value);
  // @@protoc_insertion_point(field_add:hexzpb.GameEngineFlagzState.normal_moves)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& GameEngineFlagzState::normal_moves() const {
  // @@protoc_insertion_point(field_list:hexzpb.GameEngineFlagzState.normal_moves)
  return _internal_normal_moves();
}
inline ::google::protobuf::RepeatedField<::int32_t>* GameEngineFlagzState::mutable_normal_moves() {
  // @@protoc_insertion_point(field_mutable_list:hexzpb.GameEngineFlagzState.normal_moves)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_normal_moves();
}

inline const ::google::protobuf::RepeatedField<::int32_t>& GameEngineFlagzState::_internal_normal_moves() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.normal_moves_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* GameEngineFlagzState::_internal_mutable_normal_moves() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.normal_moves_;
}

// repeated .hexzpb.GameEngineMove moves = 4;
inline int GameEngineFlagzState::_internal_moves_size() const {
  return _internal_moves().size();
}
inline int GameEngineFlagzState::moves_size() const {
  return _internal_moves_size();
}
inline void GameEngineFlagzState::clear_moves() {
  _internal_mutable_moves()->Clear();
}
inline ::hexzpb::GameEngineMove* GameEngineFlagzState::mutable_moves(int index) {
  // @@protoc_insertion_point(field_mutable:hexzpb.GameEngineFlagzState.moves)
  return _internal_mutable_moves()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hexzpb::GameEngineMove >*
GameEngineFlagzState::mutable_moves() {
  // @@protoc_insertion_point(field_mutable_list:hexzpb.GameEngineFlagzState.moves)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_moves();
}
inline const ::hexzpb::GameEngineMove& GameEngineFlagzState::moves(int index) const {
  // @@protoc_insertion_point(field_get:hexzpb.GameEngineFlagzState.moves)
    return _internal_moves().Get(index);
}
inline ::hexzpb::GameEngineMove* GameEngineFlagzState::add_moves() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::hexzpb::GameEngineMove* _add = _internal_mutable_moves()->Add();
  // @@protoc_insertion_point(field_add:hexzpb.GameEngineFlagzState.moves)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::hexzpb::GameEngineMove >&
GameEngineFlagzState::moves() const {
  // @@protoc_insertion_point(field_list:hexzpb.GameEngineFlagzState.moves)
  return _internal_moves();
}
inline const ::google::protobuf::RepeatedPtrField<::hexzpb::GameEngineMove>&
GameEngineFlagzState::_internal_moves() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.moves_;
}
inline ::google::protobuf::RepeatedPtrField<::hexzpb::GameEngineMove>*
GameEngineFlagzState::_internal_mutable_moves() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.moves_;
}

// -------------------------------------------------------------------

// GameEngineClassicState

// .hexzpb.Board board = 1;
inline bool GameEngineClassicState::has_board() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.board_ != nullptr);
  return value;
}
inline void GameEngineClassicState::clear_board() {
  if (_impl_.board_ != nullptr) _impl_.board_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::hexzpb::Board& GameEngineClassicState::_internal_board() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::hexzpb::Board* p = _impl_.board_;
  return p != nullptr ? *p : reinterpret_cast<const ::hexzpb::Board&>(::hexzpb::_Board_default_instance_);
}
inline const ::hexzpb::Board& GameEngineClassicState::board() const {
  // @@protoc_insertion_point(field_get:hexzpb.GameEngineClassicState.board)
  return _internal_board();
}
inline void GameEngineClassicState::unsafe_arena_set_allocated_board(::hexzpb::Board* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.board_);
  }
  _impl_.board_ = reinterpret_cast<::hexzpb::Board*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hexzpb.GameEngineClassicState.board)
}
inline ::hexzpb::Board* GameEngineClassicState::release_board() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hexzpb::Board* released = _impl_.board_;
  _impl_.board_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::hexzpb::Board* GameEngineClassicState::unsafe_arena_release_board() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hexzpb.GameEngineClassicState.board)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hexzpb::Board* temp = _impl_.board_;
  _impl_.board_ = nullptr;
  return temp;
}
inline ::hexzpb::Board* GameEngineClassicState::_internal_mutable_board() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.board_ == nullptr) {
    auto* p = CreateMaybeMessage<::hexzpb::Board>(GetArenaForAllocation());
    _impl_.board_ = reinterpret_cast<::hexzpb::Board*>(p);
  }
  return _impl_.board_;
}
inline ::hexzpb::Board* GameEngineClassicState::mutable_board() {
  ::hexzpb::Board* _msg = _internal_mutable_board();
  // @@protoc_insertion_point(field_mutable:hexzpb.GameEngineClassicState.board)
  return _msg;
}
inline void GameEngineClassicState::set_allocated_board(::hexzpb::Board* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::hexzpb::Board*>(_impl_.board_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::hexzpb::Board*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.board_ = reinterpret_cast<::hexzpb::Board*>(value);
  // @@protoc_insertion_point(field_set_allocated:hexzpb.GameEngineClassicState.board)
}

// -------------------------------------------------------------------

// GameEngineFreeformState

// .hexzpb.Board board = 1;
inline bool GameEngineFreeformState::has_board() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.board_ != nullptr);
  return value;
}
inline void GameEngineFreeformState::clear_board() {
  if (_impl_.board_ != nullptr) _impl_.board_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::hexzpb::Board& GameEngineFreeformState::_internal_board() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::hexzpb::Board* p = _impl_.board_;
  return p != nullptr ? *p : reinterpret_cast<const ::hexzpb::Board&>(::hexzpb::_Board_default_instance_);
}
inline const ::hexzpb::Board& GameEngineFreeformState::board() const {
  // @@protoc_insertion_point(field_get:hexzpb.GameEngineFreeformState.board)
  return _internal_board();
}
inline void GameEngineFreeformState::unsafe_arena_set_allocated_board(::hexzpb::Board* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.board_);
  }
  _impl_.board_ = reinterpret_cast<::hexzpb::Board*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hexzpb.GameEngineFreeformState.board)
}
inline ::hexzpb::Board* GameEngineFreeformState::release_board() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hexzpb::Board* released = _impl_.board_;
  _impl_.board_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::hexzpb::Board* GameEngineFreeformState::unsafe_arena_release_board() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hexzpb.GameEngineFreeformState.board)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hexzpb::Board* temp = _impl_.board_;
  _impl_.board_ = nullptr;
  return temp;
}
inline ::hexzpb::Board* GameEngineFreeformState::_internal_mutable_board() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.board_ == nullptr) {
    auto* p = CreateMaybeMessage<::hexzpb::Board>(GetArenaForAllocation());
    _impl_.board_ = reinterpret_cast<::hexzpb::Board*>(p);
  }
  return _impl_.board_;
}
inline ::hexzpb::Board* GameEngineFreeformState::mutable_board() {
  ::hexzpb::Board* _msg = _internal_mutable_board();
  // @@protoc_insertion_point(field_mutable:hexzpb.GameEngineFreeformState.board)
  return _msg;
}
inline void GameEngineFreeformState::set_allocated_board(::hexzpb::Board* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::hexzpb::Board*>(_impl_.board_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::hexzpb::Board*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.board_ = reinterpret_cast<::hexzpb::Board*>(value);
  // @@protoc_insertion_point(field_set_allocated:hexzpb.GameEngineFreeformState.board)
}

// -------------------------------------------------------------------

// GameEngineMove

// int32 player_num = 1;
inline void GameEngineMove::clear_player_num() {
  _impl_.player_num_ = 0;
}
inline ::int32_t GameEngineMove::player_num() const {
  // @@protoc_insertion_point(field_get:hexzpb.GameEngineMove.player_num)
  return _internal_player_num();
}
inline void GameEngineMove::set_player_num(::int32_t value) {
  _internal_set_player_num(value);
  // @@protoc_insertion_point(field_set:hexzpb.GameEngineMove.player_num)
}
inline ::int32_t GameEngineMove::_internal_player_num() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_num_;
}
inline void GameEngineMove::_internal_set_player_num(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_num_ = value;
}

// int32 move = 2;
inline void GameEngineMove::clear_move() {
  _impl_.move_ = 0;
}
inline ::int32_t GameEngineMove::move() const {
  // @@protoc_insertion_point(field_get:hexzpb.GameEngineMove.move)
  return _internal_move();
}
inline void GameEngineMove::set_move(::int32_t value) {
  _internal_set_move(value);
  // @@protoc_insertion_point(field_set:hexzpb.GameEngineMove.move)
}
inline ::int32_t GameEngineMove::_internal_move() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.move_;
}
inline void GameEngineMove::_internal_set_move(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.move_ = value;
}

// int32 row = 3;
inline void GameEngineMove::clear_row() {
  _impl_.row_ = 0;
}
inline ::int32_t GameEngineMove::row() const {
  // @@protoc_insertion_point(field_get:hexzpb.GameEngineMove.row)
  return _internal_row();
}
inline void GameEngineMove::set_row(::int32_t value) {
  _internal_set_row(value);
  // @@protoc_insertion_point(field_set:hexzpb.GameEngineMove.row)
}
inline ::int32_t GameEngineMove::_internal_row() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.row_;
}
inline void GameEngineMove::_internal_set_row(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.row_ = value;
}

// int32 col = 4;
inline void GameEngineMove::clear_col() {
  _impl_.col_ = 0;
}
inline ::int32_t GameEngineMove::col() const {
  // @@protoc_insertion_point(field_get:hexzpb.GameEngineMove.col)
  return _internal_col();
}
inline void GameEngineMove::set_col(::int32_t value) {
  _internal_set_col(value);
  // @@protoc_insertion_point(field_set:hexzpb.GameEngineMove.col)
}
inline ::int32_t GameEngineMove::_internal_col() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.col_;
}
inline void GameEngineMove::_internal_set_col(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.col_ = value;
}

// .hexzpb.Field.CellType cell_type = 5;
inline void GameEngineMove::clear_cell_type() {
  _impl_.cell_type_ = 0;
}
inline ::hexzpb::Field_CellType GameEngineMove::cell_type() const {
  // @@protoc_insertion_point(field_get:hexzpb.GameEngineMove.cell_type)
  return _internal_cell_type();
}
inline void GameEngineMove::set_cell_type(::hexzpb::Field_CellType value) {
  _internal_set_cell_type(value);
  // @@protoc_insertion_point(field_set:hexzpb.GameEngineMove.cell_type)
}
inline ::hexzpb::Field_CellType GameEngineMove::_internal_cell_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::hexzpb::Field_CellType>(_impl_.cell_type_);
}
inline void GameEngineMove::_internal_set_cell_type(::hexzpb::Field_CellType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cell_type_ = value;
}

// -------------------------------------------------------------------

// MCTSExample_MoveStats

// .hexzpb.GameEngineMove move = 1;
inline bool MCTSExample_MoveStats::has_move() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.move_ != nullptr);
  return value;
}
inline void MCTSExample_MoveStats::clear_move() {
  if (_impl_.move_ != nullptr) _impl_.move_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::hexzpb::GameEngineMove& MCTSExample_MoveStats::_internal_move() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::hexzpb::GameEngineMove* p = _impl_.move_;
  return p != nullptr ? *p : reinterpret_cast<const ::hexzpb::GameEngineMove&>(::hexzpb::_GameEngineMove_default_instance_);
}
inline const ::hexzpb::GameEngineMove& MCTSExample_MoveStats::move() const {
  // @@protoc_insertion_point(field_get:hexzpb.MCTSExample.MoveStats.move)
  return _internal_move();
}
inline void MCTSExample_MoveStats::unsafe_arena_set_allocated_move(::hexzpb::GameEngineMove* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.move_);
  }
  _impl_.move_ = reinterpret_cast<::hexzpb::GameEngineMove*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hexzpb.MCTSExample.MoveStats.move)
}
inline ::hexzpb::GameEngineMove* MCTSExample_MoveStats::release_move() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hexzpb::GameEngineMove* released = _impl_.move_;
  _impl_.move_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::hexzpb::GameEngineMove* MCTSExample_MoveStats::unsafe_arena_release_move() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hexzpb.MCTSExample.MoveStats.move)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hexzpb::GameEngineMove* temp = _impl_.move_;
  _impl_.move_ = nullptr;
  return temp;
}
inline ::hexzpb::GameEngineMove* MCTSExample_MoveStats::_internal_mutable_move() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.move_ == nullptr) {
    auto* p = CreateMaybeMessage<::hexzpb::GameEngineMove>(GetArenaForAllocation());
    _impl_.move_ = reinterpret_cast<::hexzpb::GameEngineMove*>(p);
  }
  return _impl_.move_;
}
inline ::hexzpb::GameEngineMove* MCTSExample_MoveStats::mutable_move() {
  ::hexzpb::GameEngineMove* _msg = _internal_mutable_move();
  // @@protoc_insertion_point(field_mutable:hexzpb.MCTSExample.MoveStats.move)
  return _msg;
}
inline void MCTSExample_MoveStats::set_allocated_move(::hexzpb::GameEngineMove* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::hexzpb::GameEngineMove*>(_impl_.move_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::hexzpb::GameEngineMove*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.move_ = reinterpret_cast<::hexzpb::GameEngineMove*>(value);
  // @@protoc_insertion_point(field_set_allocated:hexzpb.MCTSExample.MoveStats.move)
}

// int32 visits = 2;
inline void MCTSExample_MoveStats::clear_visits() {
  _impl_.visits_ = 0;
}
inline ::int32_t MCTSExample_MoveStats::visits() const {
  // @@protoc_insertion_point(field_get:hexzpb.MCTSExample.MoveStats.visits)
  return _internal_visits();
}
inline void MCTSExample_MoveStats::set_visits(::int32_t value) {
  _internal_set_visits(value);
  // @@protoc_insertion_point(field_set:hexzpb.MCTSExample.MoveStats.visits)
}
inline ::int32_t MCTSExample_MoveStats::_internal_visits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.visits_;
}
inline void MCTSExample_MoveStats::_internal_set_visits(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.visits_ = value;
}

// float win_rate = 3;
inline void MCTSExample_MoveStats::clear_win_rate() {
  _impl_.win_rate_ = 0;
}
inline float MCTSExample_MoveStats::win_rate() const {
  // @@protoc_insertion_point(field_get:hexzpb.MCTSExample.MoveStats.win_rate)
  return _internal_win_rate();
}
inline void MCTSExample_MoveStats::set_win_rate(float value) {
  _internal_set_win_rate(value);
  // @@protoc_insertion_point(field_set:hexzpb.MCTSExample.MoveStats.win_rate)
}
inline float MCTSExample_MoveStats::_internal_win_rate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.win_rate_;
}
inline void MCTSExample_MoveStats::_internal_set_win_rate(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.win_rate_ = value;
}

// -------------------------------------------------------------------

// MCTSExample

// string game_id = 1;
inline void MCTSExample::clear_game_id() {
  _impl_.game_id_.ClearToEmpty();
}
inline const std::string& MCTSExample::game_id() const {
  // @@protoc_insertion_point(field_get:hexzpb.MCTSExample.game_id)
  return _internal_game_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MCTSExample::set_game_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.game_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hexzpb.MCTSExample.game_id)
}
inline std::string* MCTSExample::mutable_game_id() {
  std::string* _s = _internal_mutable_game_id();
  // @@protoc_insertion_point(field_mutable:hexzpb.MCTSExample.game_id)
  return _s;
}
inline const std::string& MCTSExample::_internal_game_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.game_id_.Get();
}
inline void MCTSExample::_internal_set_game_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.game_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MCTSExample::_internal_mutable_game_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.game_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MCTSExample::release_game_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hexzpb.MCTSExample.game_id)
  return _impl_.game_id_.Release();
}
inline void MCTSExample::set_allocated_game_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.game_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.game_id_.IsDefault()) {
          _impl_.game_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hexzpb.MCTSExample.game_id)
}

// .hexzpb.Board board = 2;
inline bool MCTSExample::has_board() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.board_ != nullptr);
  return value;
}
inline void MCTSExample::clear_board() {
  if (_impl_.board_ != nullptr) _impl_.board_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::hexzpb::Board& MCTSExample::_internal_board() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::hexzpb::Board* p = _impl_.board_;
  return p != nullptr ? *p : reinterpret_cast<const ::hexzpb::Board&>(::hexzpb::_Board_default_instance_);
}
inline const ::hexzpb::Board& MCTSExample::board() const {
  // @@protoc_insertion_point(field_get:hexzpb.MCTSExample.board)
  return _internal_board();
}
inline void MCTSExample::unsafe_arena_set_allocated_board(::hexzpb::Board* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.board_);
  }
  _impl_.board_ = reinterpret_cast<::hexzpb::Board*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hexzpb.MCTSExample.board)
}
inline ::hexzpb::Board* MCTSExample::release_board() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hexzpb::Board* released = _impl_.board_;
  _impl_.board_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::hexzpb::Board* MCTSExample::unsafe_arena_release_board() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hexzpb.MCTSExample.board)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hexzpb::Board* temp = _impl_.board_;
  _impl_.board_ = nullptr;
  return temp;
}
inline ::hexzpb::Board* MCTSExample::_internal_mutable_board() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.board_ == nullptr) {
    auto* p = CreateMaybeMessage<::hexzpb::Board>(GetArenaForAllocation());
    _impl_.board_ = reinterpret_cast<::hexzpb::Board*>(p);
  }
  return _impl_.board_;
}
inline ::hexzpb::Board* MCTSExample::mutable_board() {
  ::hexzpb::Board* _msg = _internal_mutable_board();
  // @@protoc_insertion_point(field_mutable:hexzpb.MCTSExample.board)
  return _msg;
}
inline void MCTSExample::set_allocated_board(::hexzpb::Board* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::hexzpb::Board*>(_impl_.board_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::hexzpb::Board*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.board_ = reinterpret_cast<::hexzpb::Board*>(value);
  // @@protoc_insertion_point(field_set_allocated:hexzpb.MCTSExample.board)
}

// repeated int32 result = 3;
inline int MCTSExample::_internal_result_size() const {
  return _internal_result().size();
}
inline int MCTSExample::result_size() const {
  return _internal_result_size();
}
inline void MCTSExample::clear_result() {
  _internal_mutable_result()->Clear();
}
inline ::int32_t MCTSExample::result(int index) const {
  // @@protoc_insertion_point(field_get:hexzpb.MCTSExample.result)
  return _internal_result().Get(index);
}
inline void MCTSExample::set_result(int index, ::int32_t value) {
  _internal_mutable_result()->Set(index, value);
  // @@protoc_insertion_point(field_set:hexzpb.MCTSExample.result)
}
inline void MCTSExample::add_result(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_result()->Add(value);
  // @@protoc_insertion_point(field_add:hexzpb.MCTSExample.result)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& MCTSExample::result() const {
  // @@protoc_insertion_point(field_list:hexzpb.MCTSExample.result)
  return _internal_result();
}
inline ::google::protobuf::RepeatedField<::int32_t>* MCTSExample::mutable_result() {
  // @@protoc_insertion_point(field_mutable_list:hexzpb.MCTSExample.result)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_result();
}

inline const ::google::protobuf::RepeatedField<::int32_t>& MCTSExample::_internal_result() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.result_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* MCTSExample::_internal_mutable_result() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.result_;
}

// repeated .hexzpb.MCTSExample.MoveStats move_stats = 4;
inline int MCTSExample::_internal_move_stats_size() const {
  return _internal_move_stats().size();
}
inline int MCTSExample::move_stats_size() const {
  return _internal_move_stats_size();
}
inline void MCTSExample::clear_move_stats() {
  _internal_mutable_move_stats()->Clear();
}
inline ::hexzpb::MCTSExample_MoveStats* MCTSExample::mutable_move_stats(int index) {
  // @@protoc_insertion_point(field_mutable:hexzpb.MCTSExample.move_stats)
  return _internal_mutable_move_stats()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hexzpb::MCTSExample_MoveStats >*
MCTSExample::mutable_move_stats() {
  // @@protoc_insertion_point(field_mutable_list:hexzpb.MCTSExample.move_stats)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_move_stats();
}
inline const ::hexzpb::MCTSExample_MoveStats& MCTSExample::move_stats(int index) const {
  // @@protoc_insertion_point(field_get:hexzpb.MCTSExample.move_stats)
    return _internal_move_stats().Get(index);
}
inline ::hexzpb::MCTSExample_MoveStats* MCTSExample::add_move_stats() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::hexzpb::MCTSExample_MoveStats* _add = _internal_mutable_move_stats()->Add();
  // @@protoc_insertion_point(field_add:hexzpb.MCTSExample.move_stats)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::hexzpb::MCTSExample_MoveStats >&
MCTSExample::move_stats() const {
  // @@protoc_insertion_point(field_list:hexzpb.MCTSExample.move_stats)
  return _internal_move_stats();
}
inline const ::google::protobuf::RepeatedPtrField<::hexzpb::MCTSExample_MoveStats>&
MCTSExample::_internal_move_stats() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.move_stats_;
}
inline ::google::protobuf::RepeatedPtrField<::hexzpb::MCTSExample_MoveStats>*
MCTSExample::_internal_mutable_move_stats() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.move_stats_;
}

// -------------------------------------------------------------------

// SuggestMoveRequest

// int64 max_think_time_ms = 1;
inline void SuggestMoveRequest::clear_max_think_time_ms() {
  _impl_.max_think_time_ms_ = ::int64_t{0};
}
inline ::int64_t SuggestMoveRequest::max_think_time_ms() const {
  // @@protoc_insertion_point(field_get:hexzpb.SuggestMoveRequest.max_think_time_ms)
  return _internal_max_think_time_ms();
}
inline void SuggestMoveRequest::set_max_think_time_ms(::int64_t value) {
  _internal_set_max_think_time_ms(value);
  // @@protoc_insertion_point(field_set:hexzpb.SuggestMoveRequest.max_think_time_ms)
}
inline ::int64_t SuggestMoveRequest::_internal_max_think_time_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_think_time_ms_;
}
inline void SuggestMoveRequest::_internal_set_max_think_time_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_think_time_ms_ = value;
}

// .hexzpb.GameEngineState game_engine_state = 2;
inline bool SuggestMoveRequest::has_game_engine_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.game_engine_state_ != nullptr);
  return value;
}
inline void SuggestMoveRequest::clear_game_engine_state() {
  if (_impl_.game_engine_state_ != nullptr) _impl_.game_engine_state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::hexzpb::GameEngineState& SuggestMoveRequest::_internal_game_engine_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::hexzpb::GameEngineState* p = _impl_.game_engine_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::hexzpb::GameEngineState&>(::hexzpb::_GameEngineState_default_instance_);
}
inline const ::hexzpb::GameEngineState& SuggestMoveRequest::game_engine_state() const {
  // @@protoc_insertion_point(field_get:hexzpb.SuggestMoveRequest.game_engine_state)
  return _internal_game_engine_state();
}
inline void SuggestMoveRequest::unsafe_arena_set_allocated_game_engine_state(::hexzpb::GameEngineState* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.game_engine_state_);
  }
  _impl_.game_engine_state_ = reinterpret_cast<::hexzpb::GameEngineState*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hexzpb.SuggestMoveRequest.game_engine_state)
}
inline ::hexzpb::GameEngineState* SuggestMoveRequest::release_game_engine_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hexzpb::GameEngineState* released = _impl_.game_engine_state_;
  _impl_.game_engine_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::hexzpb::GameEngineState* SuggestMoveRequest::unsafe_arena_release_game_engine_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hexzpb.SuggestMoveRequest.game_engine_state)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hexzpb::GameEngineState* temp = _impl_.game_engine_state_;
  _impl_.game_engine_state_ = nullptr;
  return temp;
}
inline ::hexzpb::GameEngineState* SuggestMoveRequest::_internal_mutable_game_engine_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.game_engine_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::hexzpb::GameEngineState>(GetArenaForAllocation());
    _impl_.game_engine_state_ = reinterpret_cast<::hexzpb::GameEngineState*>(p);
  }
  return _impl_.game_engine_state_;
}
inline ::hexzpb::GameEngineState* SuggestMoveRequest::mutable_game_engine_state() {
  ::hexzpb::GameEngineState* _msg = _internal_mutable_game_engine_state();
  // @@protoc_insertion_point(field_mutable:hexzpb.SuggestMoveRequest.game_engine_state)
  return _msg;
}
inline void SuggestMoveRequest::set_allocated_game_engine_state(::hexzpb::GameEngineState* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::hexzpb::GameEngineState*>(_impl_.game_engine_state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::hexzpb::GameEngineState*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.game_engine_state_ = reinterpret_cast<::hexzpb::GameEngineState*>(value);
  // @@protoc_insertion_point(field_set_allocated:hexzpb.SuggestMoveRequest.game_engine_state)
}

// -------------------------------------------------------------------

// SuggestMoveStats_Score

// .hexzpb.SuggestMoveStats.ScoreKind kind = 1;
inline void SuggestMoveStats_Score::clear_kind() {
  _impl_.kind_ = 0;
}
inline ::hexzpb::SuggestMoveStats_ScoreKind SuggestMoveStats_Score::kind() const {
  // @@protoc_insertion_point(field_get:hexzpb.SuggestMoveStats.Score.kind)
  return _internal_kind();
}
inline void SuggestMoveStats_Score::set_kind(::hexzpb::SuggestMoveStats_ScoreKind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:hexzpb.SuggestMoveStats.Score.kind)
}
inline ::hexzpb::SuggestMoveStats_ScoreKind SuggestMoveStats_Score::_internal_kind() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::hexzpb::SuggestMoveStats_ScoreKind>(_impl_.kind_);
}
inline void SuggestMoveStats_Score::_internal_set_kind(::hexzpb::SuggestMoveStats_ScoreKind value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.kind_ = value;
}

// float score = 2;
inline void SuggestMoveStats_Score::clear_score() {
  _impl_.score_ = 0;
}
inline float SuggestMoveStats_Score::score() const {
  // @@protoc_insertion_point(field_get:hexzpb.SuggestMoveStats.Score.score)
  return _internal_score();
}
inline void SuggestMoveStats_Score::set_score(float value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:hexzpb.SuggestMoveStats.Score.score)
}
inline float SuggestMoveStats_Score::_internal_score() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.score_;
}
inline void SuggestMoveStats_Score::_internal_set_score(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.score_ = value;
}

// -------------------------------------------------------------------

// SuggestMoveStats_ScoredMove

// int32 row = 1;
inline void SuggestMoveStats_ScoredMove::clear_row() {
  _impl_.row_ = 0;
}
inline ::int32_t SuggestMoveStats_ScoredMove::row() const {
  // @@protoc_insertion_point(field_get:hexzpb.SuggestMoveStats.ScoredMove.row)
  return _internal_row();
}
inline void SuggestMoveStats_ScoredMove::set_row(::int32_t value) {
  _internal_set_row(value);
  // @@protoc_insertion_point(field_set:hexzpb.SuggestMoveStats.ScoredMove.row)
}
inline ::int32_t SuggestMoveStats_ScoredMove::_internal_row() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.row_;
}
inline void SuggestMoveStats_ScoredMove::_internal_set_row(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.row_ = value;
}

// int32 col = 2;
inline void SuggestMoveStats_ScoredMove::clear_col() {
  _impl_.col_ = 0;
}
inline ::int32_t SuggestMoveStats_ScoredMove::col() const {
  // @@protoc_insertion_point(field_get:hexzpb.SuggestMoveStats.ScoredMove.col)
  return _internal_col();
}
inline void SuggestMoveStats_ScoredMove::set_col(::int32_t value) {
  _internal_set_col(value);
  // @@protoc_insertion_point(field_set:hexzpb.SuggestMoveStats.ScoredMove.col)
}
inline ::int32_t SuggestMoveStats_ScoredMove::_internal_col() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.col_;
}
inline void SuggestMoveStats_ScoredMove::_internal_set_col(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.col_ = value;
}

// .hexzpb.Field.CellType type = 3;
inline void SuggestMoveStats_ScoredMove::clear_type() {
  _impl_.type_ = 0;
}
inline ::hexzpb::Field_CellType SuggestMoveStats_ScoredMove::type() const {
  // @@protoc_insertion_point(field_get:hexzpb.SuggestMoveStats.ScoredMove.type)
  return _internal_type();
}
inline void SuggestMoveStats_ScoredMove::set_type(::hexzpb::Field_CellType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:hexzpb.SuggestMoveStats.ScoredMove.type)
}
inline ::hexzpb::Field_CellType SuggestMoveStats_ScoredMove::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::hexzpb::Field_CellType>(_impl_.type_);
}
inline void SuggestMoveStats_ScoredMove::_internal_set_type(::hexzpb::Field_CellType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// repeated .hexzpb.SuggestMoveStats.Score scores = 4;
inline int SuggestMoveStats_ScoredMove::_internal_scores_size() const {
  return _internal_scores().size();
}
inline int SuggestMoveStats_ScoredMove::scores_size() const {
  return _internal_scores_size();
}
inline void SuggestMoveStats_ScoredMove::clear_scores() {
  _internal_mutable_scores()->Clear();
}
inline ::hexzpb::SuggestMoveStats_Score* SuggestMoveStats_ScoredMove::mutable_scores(int index) {
  // @@protoc_insertion_point(field_mutable:hexzpb.SuggestMoveStats.ScoredMove.scores)
  return _internal_mutable_scores()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hexzpb::SuggestMoveStats_Score >*
SuggestMoveStats_ScoredMove::mutable_scores() {
  // @@protoc_insertion_point(field_mutable_list:hexzpb.SuggestMoveStats.ScoredMove.scores)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_scores();
}
inline const ::hexzpb::SuggestMoveStats_Score& SuggestMoveStats_ScoredMove::scores(int index) const {
  // @@protoc_insertion_point(field_get:hexzpb.SuggestMoveStats.ScoredMove.scores)
    return _internal_scores().Get(index);
}
inline ::hexzpb::SuggestMoveStats_Score* SuggestMoveStats_ScoredMove::add_scores() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::hexzpb::SuggestMoveStats_Score* _add = _internal_mutable_scores()->Add();
  // @@protoc_insertion_point(field_add:hexzpb.SuggestMoveStats.ScoredMove.scores)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::hexzpb::SuggestMoveStats_Score >&
SuggestMoveStats_ScoredMove::scores() const {
  // @@protoc_insertion_point(field_list:hexzpb.SuggestMoveStats.ScoredMove.scores)
  return _internal_scores();
}
inline const ::google::protobuf::RepeatedPtrField<::hexzpb::SuggestMoveStats_Score>&
SuggestMoveStats_ScoredMove::_internal_scores() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.scores_;
}
inline ::google::protobuf::RepeatedPtrField<::hexzpb::SuggestMoveStats_Score>*
SuggestMoveStats_ScoredMove::_internal_mutable_scores() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.scores_;
}

// -------------------------------------------------------------------

// SuggestMoveStats

// repeated .hexzpb.SuggestMoveStats.ScoredMove moves = 1;
inline int SuggestMoveStats::_internal_moves_size() const {
  return _internal_moves().size();
}
inline int SuggestMoveStats::moves_size() const {
  return _internal_moves_size();
}
inline void SuggestMoveStats::clear_moves() {
  _internal_mutable_moves()->Clear();
}
inline ::hexzpb::SuggestMoveStats_ScoredMove* SuggestMoveStats::mutable_moves(int index) {
  // @@protoc_insertion_point(field_mutable:hexzpb.SuggestMoveStats.moves)
  return _internal_mutable_moves()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hexzpb::SuggestMoveStats_ScoredMove >*
SuggestMoveStats::mutable_moves() {
  // @@protoc_insertion_point(field_mutable_list:hexzpb.SuggestMoveStats.moves)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_moves();
}
inline const ::hexzpb::SuggestMoveStats_ScoredMove& SuggestMoveStats::moves(int index) const {
  // @@protoc_insertion_point(field_get:hexzpb.SuggestMoveStats.moves)
    return _internal_moves().Get(index);
}
inline ::hexzpb::SuggestMoveStats_ScoredMove* SuggestMoveStats::add_moves() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::hexzpb::SuggestMoveStats_ScoredMove* _add = _internal_mutable_moves()->Add();
  // @@protoc_insertion_point(field_add:hexzpb.SuggestMoveStats.moves)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::hexzpb::SuggestMoveStats_ScoredMove >&
SuggestMoveStats::moves() const {
  // @@protoc_insertion_point(field_list:hexzpb.SuggestMoveStats.moves)
  return _internal_moves();
}
inline const ::google::protobuf::RepeatedPtrField<::hexzpb::SuggestMoveStats_ScoredMove>&
SuggestMoveStats::_internal_moves() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.moves_;
}
inline ::google::protobuf::RepeatedPtrField<::hexzpb::SuggestMoveStats_ScoredMove>*
SuggestMoveStats::_internal_mutable_moves() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.moves_;
}

// float value = 2;
inline void SuggestMoveStats::clear_value() {
  _impl_.value_ = 0;
}
inline float SuggestMoveStats::value() const {
  // @@protoc_insertion_point(field_get:hexzpb.SuggestMoveStats.value)
  return _internal_value();
}
inline void SuggestMoveStats::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:hexzpb.SuggestMoveStats.value)
}
inline float SuggestMoveStats::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void SuggestMoveStats::_internal_set_value(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// SuggestMoveResponse

// .hexzpb.GameEngineMove move = 1;
inline bool SuggestMoveResponse::has_move() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.move_ != nullptr);
  return value;
}
inline void SuggestMoveResponse::clear_move() {
  if (_impl_.move_ != nullptr) _impl_.move_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::hexzpb::GameEngineMove& SuggestMoveResponse::_internal_move() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::hexzpb::GameEngineMove* p = _impl_.move_;
  return p != nullptr ? *p : reinterpret_cast<const ::hexzpb::GameEngineMove&>(::hexzpb::_GameEngineMove_default_instance_);
}
inline const ::hexzpb::GameEngineMove& SuggestMoveResponse::move() const {
  // @@protoc_insertion_point(field_get:hexzpb.SuggestMoveResponse.move)
  return _internal_move();
}
inline void SuggestMoveResponse::unsafe_arena_set_allocated_move(::hexzpb::GameEngineMove* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.move_);
  }
  _impl_.move_ = reinterpret_cast<::hexzpb::GameEngineMove*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hexzpb.SuggestMoveResponse.move)
}
inline ::hexzpb::GameEngineMove* SuggestMoveResponse::release_move() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hexzpb::GameEngineMove* released = _impl_.move_;
  _impl_.move_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::hexzpb::GameEngineMove* SuggestMoveResponse::unsafe_arena_release_move() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hexzpb.SuggestMoveResponse.move)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hexzpb::GameEngineMove* temp = _impl_.move_;
  _impl_.move_ = nullptr;
  return temp;
}
inline ::hexzpb::GameEngineMove* SuggestMoveResponse::_internal_mutable_move() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.move_ == nullptr) {
    auto* p = CreateMaybeMessage<::hexzpb::GameEngineMove>(GetArenaForAllocation());
    _impl_.move_ = reinterpret_cast<::hexzpb::GameEngineMove*>(p);
  }
  return _impl_.move_;
}
inline ::hexzpb::GameEngineMove* SuggestMoveResponse::mutable_move() {
  ::hexzpb::GameEngineMove* _msg = _internal_mutable_move();
  // @@protoc_insertion_point(field_mutable:hexzpb.SuggestMoveResponse.move)
  return _msg;
}
inline void SuggestMoveResponse::set_allocated_move(::hexzpb::GameEngineMove* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::hexzpb::GameEngineMove*>(_impl_.move_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::hexzpb::GameEngineMove*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.move_ = reinterpret_cast<::hexzpb::GameEngineMove*>(value);
  // @@protoc_insertion_point(field_set_allocated:hexzpb.SuggestMoveResponse.move)
}

// .hexzpb.SuggestMoveStats move_stats = 2;
inline bool SuggestMoveResponse::has_move_stats() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.move_stats_ != nullptr);
  return value;
}
inline void SuggestMoveResponse::clear_move_stats() {
  if (_impl_.move_stats_ != nullptr) _impl_.move_stats_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::hexzpb::SuggestMoveStats& SuggestMoveResponse::_internal_move_stats() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::hexzpb::SuggestMoveStats* p = _impl_.move_stats_;
  return p != nullptr ? *p : reinterpret_cast<const ::hexzpb::SuggestMoveStats&>(::hexzpb::_SuggestMoveStats_default_instance_);
}
inline const ::hexzpb::SuggestMoveStats& SuggestMoveResponse::move_stats() const {
  // @@protoc_insertion_point(field_get:hexzpb.SuggestMoveResponse.move_stats)
  return _internal_move_stats();
}
inline void SuggestMoveResponse::unsafe_arena_set_allocated_move_stats(::hexzpb::SuggestMoveStats* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.move_stats_);
  }
  _impl_.move_stats_ = reinterpret_cast<::hexzpb::SuggestMoveStats*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hexzpb.SuggestMoveResponse.move_stats)
}
inline ::hexzpb::SuggestMoveStats* SuggestMoveResponse::release_move_stats() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::hexzpb::SuggestMoveStats* released = _impl_.move_stats_;
  _impl_.move_stats_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::hexzpb::SuggestMoveStats* SuggestMoveResponse::unsafe_arena_release_move_stats() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hexzpb.SuggestMoveResponse.move_stats)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::hexzpb::SuggestMoveStats* temp = _impl_.move_stats_;
  _impl_.move_stats_ = nullptr;
  return temp;
}
inline ::hexzpb::SuggestMoveStats* SuggestMoveResponse::_internal_mutable_move_stats() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.move_stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::hexzpb::SuggestMoveStats>(GetArenaForAllocation());
    _impl_.move_stats_ = reinterpret_cast<::hexzpb::SuggestMoveStats*>(p);
  }
  return _impl_.move_stats_;
}
inline ::hexzpb::SuggestMoveStats* SuggestMoveResponse::mutable_move_stats() {
  ::hexzpb::SuggestMoveStats* _msg = _internal_mutable_move_stats();
  // @@protoc_insertion_point(field_mutable:hexzpb.SuggestMoveResponse.move_stats)
  return _msg;
}
inline void SuggestMoveResponse::set_allocated_move_stats(::hexzpb::SuggestMoveStats* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::hexzpb::SuggestMoveStats*>(_impl_.move_stats_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::hexzpb::SuggestMoveStats*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.move_stats_ = reinterpret_cast<::hexzpb::SuggestMoveStats*>(value);
  // @@protoc_insertion_point(field_set_allocated:hexzpb.SuggestMoveResponse.move_stats)
}

// -------------------------------------------------------------------

// ModelKey

// string name = 1;
inline void ModelKey::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelKey::name() const {
  // @@protoc_insertion_point(field_get:hexzpb.ModelKey.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelKey::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hexzpb.ModelKey.name)
}
inline std::string* ModelKey::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:hexzpb.ModelKey.name)
  return _s;
}
inline const std::string& ModelKey::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void ModelKey::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelKey::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* ModelKey::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hexzpb.ModelKey.name)
  return _impl_.name_.Release();
}
inline void ModelKey::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hexzpb.ModelKey.name)
}

// int32 checkpoint = 2;
inline void ModelKey::clear_checkpoint() {
  _impl_.checkpoint_ = 0;
}
inline ::int32_t ModelKey::checkpoint() const {
  // @@protoc_insertion_point(field_get:hexzpb.ModelKey.checkpoint)
  return _internal_checkpoint();
}
inline void ModelKey::set_checkpoint(::int32_t value) {
  _internal_set_checkpoint(value);
  // @@protoc_insertion_point(field_set:hexzpb.ModelKey.checkpoint)
}
inline ::int32_t ModelKey::_internal_checkpoint() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.checkpoint_;
}
inline void ModelKey::_internal_set_checkpoint(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.checkpoint_ = value;
}

// -------------------------------------------------------------------

// AddTrainingExamplesRequest

// .hexzpb.ModelKey model_key = 1;
inline bool AddTrainingExamplesRequest::has_model_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.model_key_ != nullptr);
  return value;
}
inline void AddTrainingExamplesRequest::clear_model_key() {
  if (_impl_.model_key_ != nullptr) _impl_.model_key_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::hexzpb::ModelKey& AddTrainingExamplesRequest::_internal_model_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::hexzpb::ModelKey* p = _impl_.model_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::hexzpb::ModelKey&>(::hexzpb::_ModelKey_default_instance_);
}
inline const ::hexzpb::ModelKey& AddTrainingExamplesRequest::model_key() const {
  // @@protoc_insertion_point(field_get:hexzpb.AddTrainingExamplesRequest.model_key)
  return _internal_model_key();
}
inline void AddTrainingExamplesRequest::unsafe_arena_set_allocated_model_key(::hexzpb::ModelKey* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.model_key_);
  }
  _impl_.model_key_ = reinterpret_cast<::hexzpb::ModelKey*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hexzpb.AddTrainingExamplesRequest.model_key)
}
inline ::hexzpb::ModelKey* AddTrainingExamplesRequest::release_model_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hexzpb::ModelKey* released = _impl_.model_key_;
  _impl_.model_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::hexzpb::ModelKey* AddTrainingExamplesRequest::unsafe_arena_release_model_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hexzpb.AddTrainingExamplesRequest.model_key)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hexzpb::ModelKey* temp = _impl_.model_key_;
  _impl_.model_key_ = nullptr;
  return temp;
}
inline ::hexzpb::ModelKey* AddTrainingExamplesRequest::_internal_mutable_model_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.model_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hexzpb::ModelKey>(GetArenaForAllocation());
    _impl_.model_key_ = reinterpret_cast<::hexzpb::ModelKey*>(p);
  }
  return _impl_.model_key_;
}
inline ::hexzpb::ModelKey* AddTrainingExamplesRequest::mutable_model_key() {
  ::hexzpb::ModelKey* _msg = _internal_mutable_model_key();
  // @@protoc_insertion_point(field_mutable:hexzpb.AddTrainingExamplesRequest.model_key)
  return _msg;
}
inline void AddTrainingExamplesRequest::set_allocated_model_key(::hexzpb::ModelKey* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::hexzpb::ModelKey*>(_impl_.model_key_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::hexzpb::ModelKey*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.model_key_ = reinterpret_cast<::hexzpb::ModelKey*>(value);
  // @@protoc_insertion_point(field_set_allocated:hexzpb.AddTrainingExamplesRequest.model_key)
}

// repeated .hexzpb.TrainingExample examples = 2;
inline int AddTrainingExamplesRequest::_internal_examples_size() const {
  return _internal_examples().size();
}
inline int AddTrainingExamplesRequest::examples_size() const {
  return _internal_examples_size();
}
inline void AddTrainingExamplesRequest::clear_examples() {
  _internal_mutable_examples()->Clear();
}
inline ::hexzpb::TrainingExample* AddTrainingExamplesRequest::mutable_examples(int index) {
  // @@protoc_insertion_point(field_mutable:hexzpb.AddTrainingExamplesRequest.examples)
  return _internal_mutable_examples()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hexzpb::TrainingExample >*
AddTrainingExamplesRequest::mutable_examples() {
  // @@protoc_insertion_point(field_mutable_list:hexzpb.AddTrainingExamplesRequest.examples)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_examples();
}
inline const ::hexzpb::TrainingExample& AddTrainingExamplesRequest::examples(int index) const {
  // @@protoc_insertion_point(field_get:hexzpb.AddTrainingExamplesRequest.examples)
    return _internal_examples().Get(index);
}
inline ::hexzpb::TrainingExample* AddTrainingExamplesRequest::add_examples() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::hexzpb::TrainingExample* _add = _internal_mutable_examples()->Add();
  // @@protoc_insertion_point(field_add:hexzpb.AddTrainingExamplesRequest.examples)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::hexzpb::TrainingExample >&
AddTrainingExamplesRequest::examples() const {
  // @@protoc_insertion_point(field_list:hexzpb.AddTrainingExamplesRequest.examples)
  return _internal_examples();
}
inline const ::google::protobuf::RepeatedPtrField<::hexzpb::TrainingExample>&
AddTrainingExamplesRequest::_internal_examples() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.examples_;
}
inline ::google::protobuf::RepeatedPtrField<::hexzpb::TrainingExample>*
AddTrainingExamplesRequest::_internal_mutable_examples() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.examples_;
}

// string execution_id = 3;
inline void AddTrainingExamplesRequest::clear_execution_id() {
  _impl_.execution_id_.ClearToEmpty();
}
inline const std::string& AddTrainingExamplesRequest::execution_id() const {
  // @@protoc_insertion_point(field_get:hexzpb.AddTrainingExamplesRequest.execution_id)
  return _internal_execution_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddTrainingExamplesRequest::set_execution_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.execution_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hexzpb.AddTrainingExamplesRequest.execution_id)
}
inline std::string* AddTrainingExamplesRequest::mutable_execution_id() {
  std::string* _s = _internal_mutable_execution_id();
  // @@protoc_insertion_point(field_mutable:hexzpb.AddTrainingExamplesRequest.execution_id)
  return _s;
}
inline const std::string& AddTrainingExamplesRequest::_internal_execution_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.execution_id_.Get();
}
inline void AddTrainingExamplesRequest::_internal_set_execution_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.execution_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AddTrainingExamplesRequest::_internal_mutable_execution_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.execution_id_.Mutable( GetArenaForAllocation());
}
inline std::string* AddTrainingExamplesRequest::release_execution_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hexzpb.AddTrainingExamplesRequest.execution_id)
  return _impl_.execution_id_.Release();
}
inline void AddTrainingExamplesRequest::set_allocated_execution_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.execution_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.execution_id_.IsDefault()) {
          _impl_.execution_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hexzpb.AddTrainingExamplesRequest.execution_id)
}

// -------------------------------------------------------------------

// AddTrainingExamplesResponse

// .hexzpb.AddTrainingExamplesResponse.Status status = 1;
inline void AddTrainingExamplesResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::hexzpb::AddTrainingExamplesResponse_Status AddTrainingExamplesResponse::status() const {
  // @@protoc_insertion_point(field_get:hexzpb.AddTrainingExamplesResponse.status)
  return _internal_status();
}
inline void AddTrainingExamplesResponse::set_status(::hexzpb::AddTrainingExamplesResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:hexzpb.AddTrainingExamplesResponse.status)
}
inline ::hexzpb::AddTrainingExamplesResponse_Status AddTrainingExamplesResponse::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::hexzpb::AddTrainingExamplesResponse_Status>(_impl_.status_);
}
inline void AddTrainingExamplesResponse::_internal_set_status(::hexzpb::AddTrainingExamplesResponse_Status value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.status_ = value;
}

// .hexzpb.ModelKey latest_model = 2;
inline bool AddTrainingExamplesResponse::has_latest_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.latest_model_ != nullptr);
  return value;
}
inline void AddTrainingExamplesResponse::clear_latest_model() {
  if (_impl_.latest_model_ != nullptr) _impl_.latest_model_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::hexzpb::ModelKey& AddTrainingExamplesResponse::_internal_latest_model() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::hexzpb::ModelKey* p = _impl_.latest_model_;
  return p != nullptr ? *p : reinterpret_cast<const ::hexzpb::ModelKey&>(::hexzpb::_ModelKey_default_instance_);
}
inline const ::hexzpb::ModelKey& AddTrainingExamplesResponse::latest_model() const {
  // @@protoc_insertion_point(field_get:hexzpb.AddTrainingExamplesResponse.latest_model)
  return _internal_latest_model();
}
inline void AddTrainingExamplesResponse::unsafe_arena_set_allocated_latest_model(::hexzpb::ModelKey* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.latest_model_);
  }
  _impl_.latest_model_ = reinterpret_cast<::hexzpb::ModelKey*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hexzpb.AddTrainingExamplesResponse.latest_model)
}
inline ::hexzpb::ModelKey* AddTrainingExamplesResponse::release_latest_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hexzpb::ModelKey* released = _impl_.latest_model_;
  _impl_.latest_model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::hexzpb::ModelKey* AddTrainingExamplesResponse::unsafe_arena_release_latest_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hexzpb.AddTrainingExamplesResponse.latest_model)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hexzpb::ModelKey* temp = _impl_.latest_model_;
  _impl_.latest_model_ = nullptr;
  return temp;
}
inline ::hexzpb::ModelKey* AddTrainingExamplesResponse::_internal_mutable_latest_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.latest_model_ == nullptr) {
    auto* p = CreateMaybeMessage<::hexzpb::ModelKey>(GetArenaForAllocation());
    _impl_.latest_model_ = reinterpret_cast<::hexzpb::ModelKey*>(p);
  }
  return _impl_.latest_model_;
}
inline ::hexzpb::ModelKey* AddTrainingExamplesResponse::mutable_latest_model() {
  ::hexzpb::ModelKey* _msg = _internal_mutable_latest_model();
  // @@protoc_insertion_point(field_mutable:hexzpb.AddTrainingExamplesResponse.latest_model)
  return _msg;
}
inline void AddTrainingExamplesResponse::set_allocated_latest_model(::hexzpb::ModelKey* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::hexzpb::ModelKey*>(_impl_.latest_model_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::hexzpb::ModelKey*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.latest_model_ = reinterpret_cast<::hexzpb::ModelKey*>(value);
  // @@protoc_insertion_point(field_set_allocated:hexzpb.AddTrainingExamplesResponse.latest_model)
}

// string error_message = 3;
inline void AddTrainingExamplesResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& AddTrainingExamplesResponse::error_message() const {
  // @@protoc_insertion_point(field_get:hexzpb.AddTrainingExamplesResponse.error_message)
  return _internal_error_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddTrainingExamplesResponse::set_error_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hexzpb.AddTrainingExamplesResponse.error_message)
}
inline std::string* AddTrainingExamplesResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:hexzpb.AddTrainingExamplesResponse.error_message)
  return _s;
}
inline const std::string& AddTrainingExamplesResponse::_internal_error_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.error_message_.Get();
}
inline void AddTrainingExamplesResponse::_internal_set_error_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* AddTrainingExamplesResponse::_internal_mutable_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.error_message_.Mutable( GetArenaForAllocation());
}
inline std::string* AddTrainingExamplesResponse::release_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hexzpb.AddTrainingExamplesResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void AddTrainingExamplesResponse::set_allocated_error_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_message_.IsDefault()) {
          _impl_.error_message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hexzpb.AddTrainingExamplesResponse.error_message)
}

// -------------------------------------------------------------------

// TrainingExample_ModelPredictions

// bytes priors = 1;
inline void TrainingExample_ModelPredictions::clear_priors() {
  _impl_.priors_.ClearToEmpty();
}
inline const std::string& TrainingExample_ModelPredictions::priors() const {
  // @@protoc_insertion_point(field_get:hexzpb.TrainingExample.ModelPredictions.priors)
  return _internal_priors();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrainingExample_ModelPredictions::set_priors(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.priors_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hexzpb.TrainingExample.ModelPredictions.priors)
}
inline std::string* TrainingExample_ModelPredictions::mutable_priors() {
  std::string* _s = _internal_mutable_priors();
  // @@protoc_insertion_point(field_mutable:hexzpb.TrainingExample.ModelPredictions.priors)
  return _s;
}
inline const std::string& TrainingExample_ModelPredictions::_internal_priors() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.priors_.Get();
}
inline void TrainingExample_ModelPredictions::_internal_set_priors(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.priors_.Set(value, GetArenaForAllocation());
}
inline std::string* TrainingExample_ModelPredictions::_internal_mutable_priors() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.priors_.Mutable( GetArenaForAllocation());
}
inline std::string* TrainingExample_ModelPredictions::release_priors() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hexzpb.TrainingExample.ModelPredictions.priors)
  return _impl_.priors_.Release();
}
inline void TrainingExample_ModelPredictions::set_allocated_priors(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.priors_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.priors_.IsDefault()) {
          _impl_.priors_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hexzpb.TrainingExample.ModelPredictions.priors)
}

// float value = 2;
inline void TrainingExample_ModelPredictions::clear_value() {
  _impl_.value_ = 0;
}
inline float TrainingExample_ModelPredictions::value() const {
  // @@protoc_insertion_point(field_get:hexzpb.TrainingExample.ModelPredictions.value)
  return _internal_value();
}
inline void TrainingExample_ModelPredictions::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:hexzpb.TrainingExample.ModelPredictions.value)
}
inline float TrainingExample_ModelPredictions::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void TrainingExample_ModelPredictions::_internal_set_value(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// TrainingExample_Stats

// int64 duration_micros = 1;
inline void TrainingExample_Stats::clear_duration_micros() {
  _impl_.duration_micros_ = ::int64_t{0};
}
inline ::int64_t TrainingExample_Stats::duration_micros() const {
  // @@protoc_insertion_point(field_get:hexzpb.TrainingExample.Stats.duration_micros)
  return _internal_duration_micros();
}
inline void TrainingExample_Stats::set_duration_micros(::int64_t value) {
  _internal_set_duration_micros(value);
  // @@protoc_insertion_point(field_set:hexzpb.TrainingExample.Stats.duration_micros)
}
inline ::int64_t TrainingExample_Stats::_internal_duration_micros() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.duration_micros_;
}
inline void TrainingExample_Stats::_internal_set_duration_micros(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.duration_micros_ = value;
}

// int32 valid_moves = 2;
inline void TrainingExample_Stats::clear_valid_moves() {
  _impl_.valid_moves_ = 0;
}
inline ::int32_t TrainingExample_Stats::valid_moves() const {
  // @@protoc_insertion_point(field_get:hexzpb.TrainingExample.Stats.valid_moves)
  return _internal_valid_moves();
}
inline void TrainingExample_Stats::set_valid_moves(::int32_t value) {
  _internal_set_valid_moves(value);
  // @@protoc_insertion_point(field_set:hexzpb.TrainingExample.Stats.valid_moves)
}
inline ::int32_t TrainingExample_Stats::_internal_valid_moves() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.valid_moves_;
}
inline void TrainingExample_Stats::_internal_set_valid_moves(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.valid_moves_ = value;
}

// int32 visit_count = 3;
inline void TrainingExample_Stats::clear_visit_count() {
  _impl_.visit_count_ = 0;
}
inline ::int32_t TrainingExample_Stats::visit_count() const {
  // @@protoc_insertion_point(field_get:hexzpb.TrainingExample.Stats.visit_count)
  return _internal_visit_count();
}
inline void TrainingExample_Stats::set_visit_count(::int32_t value) {
  _internal_set_visit_count(value);
  // @@protoc_insertion_point(field_set:hexzpb.TrainingExample.Stats.visit_count)
}
inline ::int32_t TrainingExample_Stats::_internal_visit_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.visit_count_;
}
inline void TrainingExample_Stats::_internal_set_visit_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.visit_count_ = value;
}

// int32 visited_children = 4;
inline void TrainingExample_Stats::clear_visited_children() {
  _impl_.visited_children_ = 0;
}
inline ::int32_t TrainingExample_Stats::visited_children() const {
  // @@protoc_insertion_point(field_get:hexzpb.TrainingExample.Stats.visited_children)
  return _internal_visited_children();
}
inline void TrainingExample_Stats::set_visited_children(::int32_t value) {
  _internal_set_visited_children(value);
  // @@protoc_insertion_point(field_set:hexzpb.TrainingExample.Stats.visited_children)
}
inline ::int32_t TrainingExample_Stats::_internal_visited_children() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.visited_children_;
}
inline void TrainingExample_Stats::_internal_set_visited_children(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.visited_children_ = value;
}

// int32 search_depth = 5;
inline void TrainingExample_Stats::clear_search_depth() {
  _impl_.search_depth_ = 0;
}
inline ::int32_t TrainingExample_Stats::search_depth() const {
  // @@protoc_insertion_point(field_get:hexzpb.TrainingExample.Stats.search_depth)
  return _internal_search_depth();
}
inline void TrainingExample_Stats::set_search_depth(::int32_t value) {
  _internal_set_search_depth(value);
  // @@protoc_insertion_point(field_set:hexzpb.TrainingExample.Stats.search_depth)
}
inline ::int32_t TrainingExample_Stats::_internal_search_depth() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.search_depth_;
}
inline void TrainingExample_Stats::_internal_set_search_depth(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.search_depth_ = value;
}

// int32 search_tree_size = 6;
inline void TrainingExample_Stats::clear_search_tree_size() {
  _impl_.search_tree_size_ = 0;
}
inline ::int32_t TrainingExample_Stats::search_tree_size() const {
  // @@protoc_insertion_point(field_get:hexzpb.TrainingExample.Stats.search_tree_size)
  return _internal_search_tree_size();
}
inline void TrainingExample_Stats::set_search_tree_size(::int32_t value) {
  _internal_set_search_tree_size(value);
  // @@protoc_insertion_point(field_set:hexzpb.TrainingExample.Stats.search_tree_size)
}
inline ::int32_t TrainingExample_Stats::_internal_search_tree_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.search_tree_size_;
}
inline void TrainingExample_Stats::_internal_set_search_tree_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.search_tree_size_ = value;
}

// int32 branch_nodes = 7;
inline void TrainingExample_Stats::clear_branch_nodes() {
  _impl_.branch_nodes_ = 0;
}
inline ::int32_t TrainingExample_Stats::branch_nodes() const {
  // @@protoc_insertion_point(field_get:hexzpb.TrainingExample.Stats.branch_nodes)
  return _internal_branch_nodes();
}
inline void TrainingExample_Stats::set_branch_nodes(::int32_t value) {
  _internal_set_branch_nodes(value);
  // @@protoc_insertion_point(field_set:hexzpb.TrainingExample.Stats.branch_nodes)
}
inline ::int32_t TrainingExample_Stats::_internal_branch_nodes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.branch_nodes_;
}
inline void TrainingExample_Stats::_internal_set_branch_nodes(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.branch_nodes_ = value;
}

// int32 min_child_vc = 8;
inline void TrainingExample_Stats::clear_min_child_vc() {
  _impl_.min_child_vc_ = 0;
}
inline ::int32_t TrainingExample_Stats::min_child_vc() const {
  // @@protoc_insertion_point(field_get:hexzpb.TrainingExample.Stats.min_child_vc)
  return _internal_min_child_vc();
}
inline void TrainingExample_Stats::set_min_child_vc(::int32_t value) {
  _internal_set_min_child_vc(value);
  // @@protoc_insertion_point(field_set:hexzpb.TrainingExample.Stats.min_child_vc)
}
inline ::int32_t TrainingExample_Stats::_internal_min_child_vc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_child_vc_;
}
inline void TrainingExample_Stats::_internal_set_min_child_vc(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.min_child_vc_ = value;
}

// int32 max_child_vc = 9;
inline void TrainingExample_Stats::clear_max_child_vc() {
  _impl_.max_child_vc_ = 0;
}
inline ::int32_t TrainingExample_Stats::max_child_vc() const {
  // @@protoc_insertion_point(field_get:hexzpb.TrainingExample.Stats.max_child_vc)
  return _internal_max_child_vc();
}
inline void TrainingExample_Stats::set_max_child_vc(::int32_t value) {
  _internal_set_max_child_vc(value);
  // @@protoc_insertion_point(field_set:hexzpb.TrainingExample.Stats.max_child_vc)
}
inline ::int32_t TrainingExample_Stats::_internal_max_child_vc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_child_vc_;
}
inline void TrainingExample_Stats::_internal_set_max_child_vc(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_child_vc_ = value;
}

// int32 selected_child_q = 13;
inline void TrainingExample_Stats::clear_selected_child_q() {
  _impl_.selected_child_q_ = 0;
}
inline ::int32_t TrainingExample_Stats::selected_child_q() const {
  // @@protoc_insertion_point(field_get:hexzpb.TrainingExample.Stats.selected_child_q)
  return _internal_selected_child_q();
}
inline void TrainingExample_Stats::set_selected_child_q(::int32_t value) {
  _internal_set_selected_child_q(value);
  // @@protoc_insertion_point(field_set:hexzpb.TrainingExample.Stats.selected_child_q)
}
inline ::int32_t TrainingExample_Stats::_internal_selected_child_q() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.selected_child_q_;
}
inline void TrainingExample_Stats::_internal_set_selected_child_q(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.selected_child_q_ = value;
}

// int32 selected_child_vc = 10;
inline void TrainingExample_Stats::clear_selected_child_vc() {
  _impl_.selected_child_vc_ = 0;
}
inline ::int32_t TrainingExample_Stats::selected_child_vc() const {
  // @@protoc_insertion_point(field_get:hexzpb.TrainingExample.Stats.selected_child_vc)
  return _internal_selected_child_vc();
}
inline void TrainingExample_Stats::set_selected_child_vc(::int32_t value) {
  _internal_set_selected_child_vc(value);
  // @@protoc_insertion_point(field_set:hexzpb.TrainingExample.Stats.selected_child_vc)
}
inline ::int32_t TrainingExample_Stats::_internal_selected_child_vc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.selected_child_vc_;
}
inline void TrainingExample_Stats::_internal_set_selected_child_vc(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.selected_child_vc_ = value;
}

// repeated int32 nodes_per_depth = 12;
inline int TrainingExample_Stats::_internal_nodes_per_depth_size() const {
  return _internal_nodes_per_depth().size();
}
inline int TrainingExample_Stats::nodes_per_depth_size() const {
  return _internal_nodes_per_depth_size();
}
inline void TrainingExample_Stats::clear_nodes_per_depth() {
  _internal_mutable_nodes_per_depth()->Clear();
}
inline ::int32_t TrainingExample_Stats::nodes_per_depth(int index) const {
  // @@protoc_insertion_point(field_get:hexzpb.TrainingExample.Stats.nodes_per_depth)
  return _internal_nodes_per_depth().Get(index);
}
inline void TrainingExample_Stats::set_nodes_per_depth(int index, ::int32_t value) {
  _internal_mutable_nodes_per_depth()->Set(index, value);
  // @@protoc_insertion_point(field_set:hexzpb.TrainingExample.Stats.nodes_per_depth)
}
inline void TrainingExample_Stats::add_nodes_per_depth(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_nodes_per_depth()->Add(value);
  // @@protoc_insertion_point(field_add:hexzpb.TrainingExample.Stats.nodes_per_depth)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TrainingExample_Stats::nodes_per_depth() const {
  // @@protoc_insertion_point(field_list:hexzpb.TrainingExample.Stats.nodes_per_depth)
  return _internal_nodes_per_depth();
}
inline ::google::protobuf::RepeatedField<::int32_t>* TrainingExample_Stats::mutable_nodes_per_depth() {
  // @@protoc_insertion_point(field_mutable_list:hexzpb.TrainingExample.Stats.nodes_per_depth)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_nodes_per_depth();
}

inline const ::google::protobuf::RepeatedField<::int32_t>& TrainingExample_Stats::_internal_nodes_per_depth() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nodes_per_depth_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* TrainingExample_Stats::_internal_mutable_nodes_per_depth() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.nodes_per_depth_;
}

// -------------------------------------------------------------------

// TrainingExample

// int64 unix_micros = 1;
inline void TrainingExample::clear_unix_micros() {
  _impl_.unix_micros_ = ::int64_t{0};
}
inline ::int64_t TrainingExample::unix_micros() const {
  // @@protoc_insertion_point(field_get:hexzpb.TrainingExample.unix_micros)
  return _internal_unix_micros();
}
inline void TrainingExample::set_unix_micros(::int64_t value) {
  _internal_set_unix_micros(value);
  // @@protoc_insertion_point(field_set:hexzpb.TrainingExample.unix_micros)
}
inline ::int64_t TrainingExample::_internal_unix_micros() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.unix_micros_;
}
inline void TrainingExample::_internal_set_unix_micros(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.unix_micros_ = value;
}

// int32 turn = 7;
inline void TrainingExample::clear_turn() {
  _impl_.turn_ = 0;
}
inline ::int32_t TrainingExample::turn() const {
  // @@protoc_insertion_point(field_get:hexzpb.TrainingExample.turn)
  return _internal_turn();
}
inline void TrainingExample::set_turn(::int32_t value) {
  _internal_set_turn(value);
  // @@protoc_insertion_point(field_set:hexzpb.TrainingExample.turn)
}
inline ::int32_t TrainingExample::_internal_turn() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.turn_;
}
inline void TrainingExample::_internal_set_turn(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.turn_ = value;
}

// .hexzpb.GameEngineMove move = 9;
inline bool TrainingExample::has_move() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.move_ != nullptr);
  return value;
}
inline void TrainingExample::clear_move() {
  if (_impl_.move_ != nullptr) _impl_.move_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::hexzpb::GameEngineMove& TrainingExample::_internal_move() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::hexzpb::GameEngineMove* p = _impl_.move_;
  return p != nullptr ? *p : reinterpret_cast<const ::hexzpb::GameEngineMove&>(::hexzpb::_GameEngineMove_default_instance_);
}
inline const ::hexzpb::GameEngineMove& TrainingExample::move() const {
  // @@protoc_insertion_point(field_get:hexzpb.TrainingExample.move)
  return _internal_move();
}
inline void TrainingExample::unsafe_arena_set_allocated_move(::hexzpb::GameEngineMove* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.move_);
  }
  _impl_.move_ = reinterpret_cast<::hexzpb::GameEngineMove*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hexzpb.TrainingExample.move)
}
inline ::hexzpb::GameEngineMove* TrainingExample::release_move() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::hexzpb::GameEngineMove* released = _impl_.move_;
  _impl_.move_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::hexzpb::GameEngineMove* TrainingExample::unsafe_arena_release_move() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hexzpb.TrainingExample.move)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::hexzpb::GameEngineMove* temp = _impl_.move_;
  _impl_.move_ = nullptr;
  return temp;
}
inline ::hexzpb::GameEngineMove* TrainingExample::_internal_mutable_move() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.move_ == nullptr) {
    auto* p = CreateMaybeMessage<::hexzpb::GameEngineMove>(GetArenaForAllocation());
    _impl_.move_ = reinterpret_cast<::hexzpb::GameEngineMove*>(p);
  }
  return _impl_.move_;
}
inline ::hexzpb::GameEngineMove* TrainingExample::mutable_move() {
  ::hexzpb::GameEngineMove* _msg = _internal_mutable_move();
  // @@protoc_insertion_point(field_mutable:hexzpb.TrainingExample.move)
  return _msg;
}
inline void TrainingExample::set_allocated_move(::hexzpb::GameEngineMove* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::hexzpb::GameEngineMove*>(_impl_.move_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::hexzpb::GameEngineMove*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.move_ = reinterpret_cast<::hexzpb::GameEngineMove*>(value);
  // @@protoc_insertion_point(field_set_allocated:hexzpb.TrainingExample.move)
}

// .hexzpb.TrainingExample.Encoding encoding = 6;
inline void TrainingExample::clear_encoding() {
  _impl_.encoding_ = 0;
}
inline ::hexzpb::TrainingExample_Encoding TrainingExample::encoding() const {
  // @@protoc_insertion_point(field_get:hexzpb.TrainingExample.encoding)
  return _internal_encoding();
}
inline void TrainingExample::set_encoding(::hexzpb::TrainingExample_Encoding value) {
  _internal_set_encoding(value);
  // @@protoc_insertion_point(field_set:hexzpb.TrainingExample.encoding)
}
inline ::hexzpb::TrainingExample_Encoding TrainingExample::_internal_encoding() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::hexzpb::TrainingExample_Encoding>(_impl_.encoding_);
}
inline void TrainingExample::_internal_set_encoding(::hexzpb::TrainingExample_Encoding value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.encoding_ = value;
}

// bytes board = 2;
inline void TrainingExample::clear_board() {
  _impl_.board_.ClearToEmpty();
}
inline const std::string& TrainingExample::board() const {
  // @@protoc_insertion_point(field_get:hexzpb.TrainingExample.board)
  return _internal_board();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrainingExample::set_board(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.board_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hexzpb.TrainingExample.board)
}
inline std::string* TrainingExample::mutable_board() {
  std::string* _s = _internal_mutable_board();
  // @@protoc_insertion_point(field_mutable:hexzpb.TrainingExample.board)
  return _s;
}
inline const std::string& TrainingExample::_internal_board() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.board_.Get();
}
inline void TrainingExample::_internal_set_board(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.board_.Set(value, GetArenaForAllocation());
}
inline std::string* TrainingExample::_internal_mutable_board() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.board_.Mutable( GetArenaForAllocation());
}
inline std::string* TrainingExample::release_board() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hexzpb.TrainingExample.board)
  return _impl_.board_.Release();
}
inline void TrainingExample::set_allocated_board(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.board_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.board_.IsDefault()) {
          _impl_.board_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hexzpb.TrainingExample.board)
}

// bytes action_mask = 8;
inline void TrainingExample::clear_action_mask() {
  _impl_.action_mask_.ClearToEmpty();
}
inline const std::string& TrainingExample::action_mask() const {
  // @@protoc_insertion_point(field_get:hexzpb.TrainingExample.action_mask)
  return _internal_action_mask();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrainingExample::set_action_mask(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.action_mask_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hexzpb.TrainingExample.action_mask)
}
inline std::string* TrainingExample::mutable_action_mask() {
  std::string* _s = _internal_mutable_action_mask();
  // @@protoc_insertion_point(field_mutable:hexzpb.TrainingExample.action_mask)
  return _s;
}
inline const std::string& TrainingExample::_internal_action_mask() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.action_mask_.Get();
}
inline void TrainingExample::_internal_set_action_mask(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.action_mask_.Set(value, GetArenaForAllocation());
}
inline std::string* TrainingExample::_internal_mutable_action_mask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.action_mask_.Mutable( GetArenaForAllocation());
}
inline std::string* TrainingExample::release_action_mask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hexzpb.TrainingExample.action_mask)
  return _impl_.action_mask_.Release();
}
inline void TrainingExample::set_allocated_action_mask(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.action_mask_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.action_mask_.IsDefault()) {
          _impl_.action_mask_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hexzpb.TrainingExample.action_mask)
}

// bytes move_probs = 3;
inline void TrainingExample::clear_move_probs() {
  _impl_.move_probs_.ClearToEmpty();
}
inline const std::string& TrainingExample::move_probs() const {
  // @@protoc_insertion_point(field_get:hexzpb.TrainingExample.move_probs)
  return _internal_move_probs();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrainingExample::set_move_probs(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.move_probs_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hexzpb.TrainingExample.move_probs)
}
inline std::string* TrainingExample::mutable_move_probs() {
  std::string* _s = _internal_mutable_move_probs();
  // @@protoc_insertion_point(field_mutable:hexzpb.TrainingExample.move_probs)
  return _s;
}
inline const std::string& TrainingExample::_internal_move_probs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.move_probs_.Get();
}
inline void TrainingExample::_internal_set_move_probs(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.move_probs_.Set(value, GetArenaForAllocation());
}
inline std::string* TrainingExample::_internal_mutable_move_probs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.move_probs_.Mutable( GetArenaForAllocation());
}
inline std::string* TrainingExample::release_move_probs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hexzpb.TrainingExample.move_probs)
  return _impl_.move_probs_.Release();
}
inline void TrainingExample::set_allocated_move_probs(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.move_probs_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.move_probs_.IsDefault()) {
          _impl_.move_probs_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hexzpb.TrainingExample.move_probs)
}

// float result = 4;
inline void TrainingExample::clear_result() {
  _impl_.result_ = 0;
}
inline float TrainingExample::result() const {
  // @@protoc_insertion_point(field_get:hexzpb.TrainingExample.result)
  return _internal_result();
}
inline void TrainingExample::set_result(float value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:hexzpb.TrainingExample.result)
}
inline float TrainingExample::_internal_result() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.result_;
}
inline void TrainingExample::_internal_set_result(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.result_ = value;
}

// .hexzpb.TrainingExample.ModelPredictions model_predictions = 10;
inline bool TrainingExample::has_model_predictions() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.model_predictions_ != nullptr);
  return value;
}
inline void TrainingExample::clear_model_predictions() {
  if (_impl_.model_predictions_ != nullptr) _impl_.model_predictions_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::hexzpb::TrainingExample_ModelPredictions& TrainingExample::_internal_model_predictions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::hexzpb::TrainingExample_ModelPredictions* p = _impl_.model_predictions_;
  return p != nullptr ? *p : reinterpret_cast<const ::hexzpb::TrainingExample_ModelPredictions&>(::hexzpb::_TrainingExample_ModelPredictions_default_instance_);
}
inline const ::hexzpb::TrainingExample_ModelPredictions& TrainingExample::model_predictions() const {
  // @@protoc_insertion_point(field_get:hexzpb.TrainingExample.model_predictions)
  return _internal_model_predictions();
}
inline void TrainingExample::unsafe_arena_set_allocated_model_predictions(::hexzpb::TrainingExample_ModelPredictions* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.model_predictions_);
  }
  _impl_.model_predictions_ = reinterpret_cast<::hexzpb::TrainingExample_ModelPredictions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hexzpb.TrainingExample.model_predictions)
}
inline ::hexzpb::TrainingExample_ModelPredictions* TrainingExample::release_model_predictions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::hexzpb::TrainingExample_ModelPredictions* released = _impl_.model_predictions_;
  _impl_.model_predictions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::hexzpb::TrainingExample_ModelPredictions* TrainingExample::unsafe_arena_release_model_predictions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hexzpb.TrainingExample.model_predictions)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::hexzpb::TrainingExample_ModelPredictions* temp = _impl_.model_predictions_;
  _impl_.model_predictions_ = nullptr;
  return temp;
}
inline ::hexzpb::TrainingExample_ModelPredictions* TrainingExample::_internal_mutable_model_predictions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.model_predictions_ == nullptr) {
    auto* p = CreateMaybeMessage<::hexzpb::TrainingExample_ModelPredictions>(GetArenaForAllocation());
    _impl_.model_predictions_ = reinterpret_cast<::hexzpb::TrainingExample_ModelPredictions*>(p);
  }
  return _impl_.model_predictions_;
}
inline ::hexzpb::TrainingExample_ModelPredictions* TrainingExample::mutable_model_predictions() {
  ::hexzpb::TrainingExample_ModelPredictions* _msg = _internal_mutable_model_predictions();
  // @@protoc_insertion_point(field_mutable:hexzpb.TrainingExample.model_predictions)
  return _msg;
}
inline void TrainingExample::set_allocated_model_predictions(::hexzpb::TrainingExample_ModelPredictions* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::hexzpb::TrainingExample_ModelPredictions*>(_impl_.model_predictions_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::hexzpb::TrainingExample_ModelPredictions*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.model_predictions_ = reinterpret_cast<::hexzpb::TrainingExample_ModelPredictions*>(value);
  // @@protoc_insertion_point(field_set_allocated:hexzpb.TrainingExample.model_predictions)
}

// .hexzpb.TrainingExample.Stats stats = 5;
inline bool TrainingExample::has_stats() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stats_ != nullptr);
  return value;
}
inline void TrainingExample::clear_stats() {
  if (_impl_.stats_ != nullptr) _impl_.stats_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::hexzpb::TrainingExample_Stats& TrainingExample::_internal_stats() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::hexzpb::TrainingExample_Stats* p = _impl_.stats_;
  return p != nullptr ? *p : reinterpret_cast<const ::hexzpb::TrainingExample_Stats&>(::hexzpb::_TrainingExample_Stats_default_instance_);
}
inline const ::hexzpb::TrainingExample_Stats& TrainingExample::stats() const {
  // @@protoc_insertion_point(field_get:hexzpb.TrainingExample.stats)
  return _internal_stats();
}
inline void TrainingExample::unsafe_arena_set_allocated_stats(::hexzpb::TrainingExample_Stats* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stats_);
  }
  _impl_.stats_ = reinterpret_cast<::hexzpb::TrainingExample_Stats*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hexzpb.TrainingExample.stats)
}
inline ::hexzpb::TrainingExample_Stats* TrainingExample::release_stats() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hexzpb::TrainingExample_Stats* released = _impl_.stats_;
  _impl_.stats_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::hexzpb::TrainingExample_Stats* TrainingExample::unsafe_arena_release_stats() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hexzpb.TrainingExample.stats)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hexzpb::TrainingExample_Stats* temp = _impl_.stats_;
  _impl_.stats_ = nullptr;
  return temp;
}
inline ::hexzpb::TrainingExample_Stats* TrainingExample::_internal_mutable_stats() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::hexzpb::TrainingExample_Stats>(GetArenaForAllocation());
    _impl_.stats_ = reinterpret_cast<::hexzpb::TrainingExample_Stats*>(p);
  }
  return _impl_.stats_;
}
inline ::hexzpb::TrainingExample_Stats* TrainingExample::mutable_stats() {
  ::hexzpb::TrainingExample_Stats* _msg = _internal_mutable_stats();
  // @@protoc_insertion_point(field_mutable:hexzpb.TrainingExample.stats)
  return _msg;
}
inline void TrainingExample::set_allocated_stats(::hexzpb::TrainingExample_Stats* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::hexzpb::TrainingExample_Stats*>(_impl_.stats_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::hexzpb::TrainingExample_Stats*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.stats_ = reinterpret_cast<::hexzpb::TrainingExample_Stats*>(value);
  // @@protoc_insertion_point(field_set_allocated:hexzpb.TrainingExample.stats)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace hexzpb


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::hexzpb::Board_GameState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::hexzpb::Board_GameState>() {
  return ::hexzpb::Board_GameState_descriptor();
}
template <>
struct is_proto_enum<::hexzpb::Field_CellType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::hexzpb::Field_CellType>() {
  return ::hexzpb::Field_CellType_descriptor();
}
template <>
struct is_proto_enum<::hexzpb::SuggestMoveStats_ScoreKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::hexzpb::SuggestMoveStats_ScoreKind>() {
  return ::hexzpb::SuggestMoveStats_ScoreKind_descriptor();
}
template <>
struct is_proto_enum<::hexzpb::AddTrainingExamplesResponse_Status> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::hexzpb::AddTrainingExamplesResponse_Status>() {
  return ::hexzpb::AddTrainingExamplesResponse_Status_descriptor();
}
template <>
struct is_proto_enum<::hexzpb::TrainingExample_Encoding> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::hexzpb::TrainingExample_Encoding>() {
  return ::hexzpb::TrainingExample_Encoding_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_hexz_2eproto_2epb_2eh
